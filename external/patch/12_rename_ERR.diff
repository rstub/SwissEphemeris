diff --git a/src/libswe/swecl.c b/src/libswe/swecl.c
index 17133d6..95e4ea4 100644
--- a/src/libswe/swecl.c
+++ b/src/libswe/swecl.c
@@ -502,7 +502,7 @@ struct saros_data saros_data_lunar[NSAROS_LUNAR] = {
  * all of these errors can grow up to a km or more. 
  * 
  * Function returns:
- * -1 (ERR)	on error (e.g. if swe_calc() for sun or moon fails)
+ * -1 (SE_ERR)	on error (e.g. if swe_calc() for sun or moon fails)
  * 0		if there is no solar eclipse at tjd
  * SE_ECL_TOTAL
  * SE_ECL_ANNULAR
@@ -562,7 +562,7 @@ int32 CALL_CONV swe_sol_eclipse_where(
   swi_set_tid_acc(tjd_ut, ifl, 0, serr);
   if ((retflag = eclipse_where(tjd_ut, SE_SUN, NULL, ifl, geopos, dcore, serr)) < 0)
     return retflag;
-  if ((retflag2 = eclipse_how(tjd_ut, SE_SUN, NULL, ifl, geopos[0], geopos[1], 0, attr, serr)) == ERR)
+  if ((retflag2 = eclipse_how(tjd_ut, SE_SUN, NULL, ifl, geopos[0], geopos[1], 0, attr, serr)) == SE_ERR)
     return retflag2;
   attr[3] = dcore[0];
   return retflag;
@@ -610,7 +610,7 @@ int32 CALL_CONV swe_lun_occult_where(
     ipl = SE_PLUTO;
   if ((retflag = eclipse_where(tjd_ut, ipl, starname, ifl, geopos, dcore, serr)) < 0)
     return retflag;
-  if ((retflag2 = eclipse_how(tjd_ut, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == ERR)
+  if ((retflag2 = eclipse_how(tjd_ut, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == SE_ERR)
     return retflag2;
   attr[3] = dcore[0];
   return retflag;
@@ -657,16 +657,16 @@ static int32 eclipse_where( double tjd_ut, int32 ipl, char *starname, int32 ifl,
   deltat = swe_deltat_ex(tjd_ut, ifl, serr);
   tjd = tjd_ut + deltat;
   /* moon in cartesian coordinates */
-  if ((retc = swe_calc(tjd, SE_MOON, iflag, rm, serr)) == ERR)
+  if ((retc = swe_calc(tjd, SE_MOON, iflag, rm, serr)) == SE_ERR)
     return retc;
   /* moon in polar coordinates */
-  if ((retc = swe_calc(tjd, SE_MOON, iflag2, lm, serr)) == ERR)
+  if ((retc = swe_calc(tjd, SE_MOON, iflag2, lm, serr)) == SE_ERR)
     return retc;
   /* sun in cartesian coordinates */
-  if ((retc = calc_planet_star(tjd, ipl, starname, iflag, rs, serr)) == ERR)
+  if ((retc = calc_planet_star(tjd, ipl, starname, iflag, rs, serr)) == SE_ERR)
     return retc;
   /* sun in polar coordinates */
-  if ((retc = calc_planet_star(tjd, ipl, starname, iflag2, ls, serr)) == ERR)
+  if ((retc = calc_planet_star(tjd, ipl, starname, iflag2, ls, serr)) == SE_ERR)
     return retc;
   /* save sun position */
   for (i = 0; i <= 2; i++)
@@ -919,20 +919,20 @@ int32 CALL_CONV swe_sol_eclipse_how(
   if (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for eclipses must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   ifl &= SEFLG_EPHMASK; 
   swi_set_tid_acc(tjd_ut, ifl, 0, serr);
-  if ((retflag = eclipse_how(tjd_ut, SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == ERR)
+  if ((retflag = eclipse_how(tjd_ut, SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == SE_ERR)
     return retflag;
-  if ((retflag2 = eclipse_where(tjd_ut, SE_SUN, NULL, ifl, geopos2, dcore, serr)) == ERR)
+  if ((retflag2 = eclipse_where(tjd_ut, SE_SUN, NULL, ifl, geopos2, dcore, serr)) == SE_ERR)
     return retflag2;
   if (retflag)
     retflag |= (retflag2 & (SE_ECL_CENTRAL | SE_ECL_NONCENTRAL));
   attr[3] = dcore[0];
   swe_set_topo(geopos[0], geopos[1], geopos[2]);
-  if (swe_calc_ut(tjd_ut, SE_SUN, ifl | SEFLG_TOPOCTR | SEFLG_EQUATORIAL, ls, serr) == ERR)
-    return ERR;
+  if (swe_calc_ut(tjd_ut, SE_SUN, ifl | SEFLG_TOPOCTR | SEFLG_EQUATORIAL, ls, serr) == SE_ERR)
+    return SE_ERR;
   swe_azalt(tjd_ut, SE_EQU2HOR, geopos, 0, 10, ls, xaz);
   attr[4] = xaz[0];
   attr[5] = xaz[1];
@@ -969,14 +969,14 @@ static int32 eclipse_how( double tjd_ut, int32 ipl, char *starname, int32 ifl,
   geopos[2] = geohgt;
   te = tjd_ut + swe_deltat_ex(tjd_ut, ifl, serr);
   swe_set_topo(geolon, geolat, geohgt);
-  if (calc_planet_star(te, ipl, starname, iflag, ls, serr) == ERR)
-    return ERR;
-  if (swe_calc(te, SE_MOON, iflag, lm, serr) == ERR)
-    return ERR;
-  if (calc_planet_star(te, ipl, starname, iflagcart, xs, serr) == ERR)
-    return ERR;
-  if (swe_calc(te, SE_MOON, iflagcart, xm, serr) == ERR)
-    return ERR;
+  if (calc_planet_star(te, ipl, starname, iflag, ls, serr) == SE_ERR)
+    return SE_ERR;
+  if (swe_calc(te, SE_MOON, iflag, lm, serr) == SE_ERR)
+    return SE_ERR;
+  if (calc_planet_star(te, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+    return SE_ERR;
+  if (swe_calc(te, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+    return SE_ERR;
   /*
    * radius of planet disk in AU
    */
@@ -1186,12 +1186,12 @@ int32 CALL_CONV swe_sol_eclipse_when_glob(double tjd_start, int32 ifl, int32 ifl
   if (ifltype == (SE_ECL_PARTIAL | SE_ECL_CENTRAL)) {
     if (serr != NULL)
       strcpy(serr, "central partial eclipses do not exist");
-    return ERR;
+    return SE_ERR;
   }
   if (ifltype == (SE_ECL_ANNULAR_TOTAL | SE_ECL_NONCENTRAL)) {
     if (serr != NULL)
       strcpy(serr, "non-central hybrid (annular-total) eclipses do not exist");
-    return ERR;
+    return SE_ERR;
   }
   if (ifltype == 0)
     ifltype = SE_ECL_TOTAL | SE_ECL_ANNULAR | SE_ECL_PARTIAL
@@ -1254,14 +1254,14 @@ next_try:
        dt > 0.0001; 
        dt /= dtdiv) {
     for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
-      if (swe_calc(t, SE_SUN, iflag, ls, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
+      if (swe_calc(t, SE_SUN, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
       for (m = 0; m < 3; m++) {
         xa[m] = xs[m] / ls[2];
         xb[m] = xm[m] / lm[2];
@@ -1277,13 +1277,13 @@ next_try:
   tjds = tjd - swe_deltat_ex(tjd, ifl, serr);
   tjds = tjd - swe_deltat_ex(tjds, ifl, serr);
   tjds = tjd = tjd - swe_deltat_ex(tjds, ifl, serr);
-  if ((retflag = eclipse_where(tjd, SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+  if ((retflag = eclipse_where(tjd, SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
     return retflag;
   retflag2 = retflag;
     /* in extreme cases _where() returns no eclipse, where there is
      * actually a very small one, therefore call _how() with the
      * coordinates returned by _where(): */
-  if ((retflag2 = eclipse_how(tjd, SE_SUN, NULL, ifl, geopos[0], geopos[1], 0, attr, serr)) == ERR)
+  if ((retflag2 = eclipse_how(tjd, SE_SUN, NULL, ifl, geopos[0], geopos[1], 0, attr, serr)) == SE_ERR)
     return retflag2;
   if (retflag2 == 0) {
     K += direction;
@@ -1299,7 +1299,7 @@ next_try:
    * eclipse type, SE_ECL_TOTAL, _ANNULAR, etc.
    * SE_ECL_ANNULAR_TOTAL will be discovered later
    */
-  if ((retflag = eclipse_where(tjd, SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+  if ((retflag = eclipse_where(tjd, SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
     return retflag;
   if (retflag == 0) {	/* can happen with extremely small percentage */
     retflag = SE_ECL_PARTIAL | SE_ECL_NONCENTRAL;
@@ -1363,7 +1363,7 @@ next_try:
       i1 = 6; i2 = 7;
     }
     for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
-      if ((retflag2 = eclipse_where(t, SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+      if ((retflag2 = eclipse_where(t, SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
         return retflag2;
       if (n == 0)
         dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
@@ -1378,7 +1378,7 @@ next_try:
     for (m = 0, dt = dtb; m < 3; m++, dt /= 3) {
       for (j = i1; j <= i2; j += (i2 - i1)) {
         for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
-          if ((retflag2 = eclipse_where(t, SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+          if ((retflag2 = eclipse_where(t, SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
             return retflag2;
           if (n == 0)
             dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
@@ -1396,13 +1396,13 @@ next_try:
    * annular-total eclipses
    */
   if (retflag & SE_ECL_TOTAL) {
-    if ((retflag2 = eclipse_where(tret[0], SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[0], SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[0] = *dcore;
-    if ((retflag2 = eclipse_where(tret[4], SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[4], SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[1] = *dcore;
-    if ((retflag2 = eclipse_where(tret[5], SE_SUN, NULL, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[5], SE_SUN, NULL, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[2] = *dcore;
     /* the maximum is always total, and there is either one or
@@ -1433,10 +1433,10 @@ next_try:
   for (i = 0; i < 2; i++) {
     j = i + k;
     tt = tret[j] + swe_deltat_ex(tret[j], ifl, serr);
-    if (swe_calc(tt, SE_SUN, iflag, ls, serr) == ERR)
-        return ERR;
-    if (swe_calc(tt, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+    if (swe_calc(tt, SE_SUN, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+    if (swe_calc(tt, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
     dc[i] = swe_degnorm(ls[0] - lm[0]);
     if (dc[i] > 180)
       dc[i] -= 360;
@@ -1454,10 +1454,10 @@ next_try:
         j++, dt /= 3) {
       for (i = 0, t = tjd; i <= 1; i++, t -= dt) {
         tt = t + swe_deltat_ex(t, ifl, serr);
-        if (swe_calc(tt, SE_SUN, iflag, ls, serr) == ERR)
-          return ERR;
-        if (swe_calc(tt, SE_MOON, iflag, lm, serr) == ERR)
-          return ERR;
+        if (swe_calc(tt, SE_SUN, iflag, ls, serr) == SE_ERR)
+          return SE_ERR;
+        if (swe_calc(tt, SE_MOON, iflag, lm, serr) == SE_ERR)
+          return SE_ERR;
         dc[i] = swe_degnorm(ls[0] - lm[0]);
         if (dc[i] > 180)
           dc[i] -= 360;
@@ -1585,14 +1585,14 @@ int32 CALL_CONV swe_lun_occult_when_glob(
   if (ifltype == (SE_ECL_PARTIAL | SE_ECL_CENTRAL)) {
     if (serr != NULL)
       strcpy(serr, "central partial eclipses do not exist");
-    return ERR;
+    return SE_ERR;
   }
   if (ipl != SE_SUN) {
     ifltype2 = (ifltype & ~(SE_ECL_NONCENTRAL | SE_ECL_CENTRAL));
     if (ifltype2 == SE_ECL_ANNULAR || ifltype == SE_ECL_ANNULAR_TOTAL) {
       if (serr != NULL)
 	sprintf(serr, "annular occulation do not exist for object %d %s\n", ipl, starname);
-      return ERR;
+      return SE_ERR;
     }
   }
   if (ipl != SE_SUN && (ifltype & (SE_ECL_ANNULAR | SE_ECL_ANNULAR_TOTAL)))
@@ -1614,28 +1614,28 @@ int32 CALL_CONV swe_lun_occult_when_glob(
   t = tjd_start;
   tjd = t;
 next_try:
-  if (calc_planet_star(t, ipl, starname, ifl, ls, serr) == ERR)
-      return ERR;
+  if (calc_planet_star(t, ipl, starname, ifl, ls, serr) == SE_ERR)
+      return SE_ERR;
   /* fixed stars with an ecliptic latitude > 7  or < -7 cannot have 
    * an occultation. Even lunar parallax andd proper motion of star
    * will never allow it. */
   if (fabs(ls[1]) > 7 && starname != NULL && *starname != '\0') {
     if (serr != NULL) 
       sprintf(serr, "occultation never occurs: star %s has ecl. lat. %.1f", starname, ls[1]);
-    return ERR;
+    return SE_ERR;
   }
-  if (swe_calc(t, SE_MOON, ifl, lm, serr) == ERR)
-      return ERR;
+  if (swe_calc(t, SE_MOON, ifl, lm, serr) == SE_ERR)
+      return SE_ERR;
   dl = swe_degnorm(ls[0] - lm[0]);
   if (direction < 0)
     dl -= 360;
   /* get rough conjunction in ecliptic longitude */
   while (fabs(dl) > 0.1) {
     t += dl / 13;
-    if (calc_planet_star(t, ipl, starname, ifl, ls, serr) == ERR)
-	return ERR;
-    if (swe_calc(t, SE_MOON, ifl, lm, serr) == ERR)
-	return ERR;
+    if (calc_planet_star(t, ipl, starname, ifl, ls, serr) == SE_ERR)
+	return SE_ERR;
+    if (swe_calc(t, SE_MOON, ifl, lm, serr) == SE_ERR)
+	return SE_ERR;
     dl = swe_degnorm(ls[0] - lm[0]);
     if (dl > 180) dl -= 360;
   }
@@ -1675,14 +1675,14 @@ next_try:
        dt > 0.0001; 
        dt /= dtdiv) {
     for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
-      if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
-      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
+      if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
+      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
       dc[i] = acos(swi_dot_prod_unit(xs, xm)) * RADTODEG;
       rmoon = asin(RMOON / lm[2]) * RADTODEG;
       rsun = asin(drad / ls[2]) * RADTODEG;
@@ -1693,13 +1693,13 @@ next_try:
   }
   tjd -= swe_deltat_ex(tjd, ifl, serr);
   tjds = tjd;
-  if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+  if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
     return retflag;
   retflag2 = retflag;
     /* in extreme cases _where() returns no eclipse, where there is
      * actually a very small one, therefore call _how() with the
      * coordinates returned by _where(): */
-  /* if ((retflag2 = eclipse_how(tjd, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == ERR)
+  /* if ((retflag2 = eclipse_how(tjd, ipl, starname, ifl, geopos[0], geopos[1], 0, attr, serr)) == SE_ERR)
     return retflag2; */
   if (retflag2 == 0) {
     /* only one try! */
@@ -1726,7 +1726,7 @@ next_try:
    * eclipse type, SE_ECL_TOTAL, _ANNULAR, etc.
    * SE_ECL_ANNULAR_TOTAL will be discovered later
    */
-  if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+  if ((retflag = eclipse_where(tjd, ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
     return retflag;
   if (retflag == 0) {	/* can happen with extremely small percentage */
     retflag = SE_ECL_PARTIAL | SE_ECL_NONCENTRAL;
@@ -1820,7 +1820,7 @@ next_try:
       i1 = 6; i2 = 7;
     }
     for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
-      if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+      if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
         return retflag2;
       if (n == 0)
         dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
@@ -1835,7 +1835,7 @@ next_try:
     for (m = 0, dt = dtb; m < 3; m++, dt /= 3) {
       for (j = i1; j <= i2; j += (i2 - i1)) {
         for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
-          if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+          if ((retflag2 = eclipse_where(t, ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
             return retflag2;
           if (n == 0)
             dc[i] = dcore[4] / 2 + de / dcore[5] - dcore[2];
@@ -1853,13 +1853,13 @@ next_try:
    * annular-total eclipses
    */
   if (retflag & SE_ECL_TOTAL) {
-    if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[0] = *dcore;
-    if ((retflag2 = eclipse_where(tret[4], ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[4], ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[1] = *dcore;
-    if ((retflag2 = eclipse_where(tret[5], ipl, starname, ifl, geopos, dcore, serr)) == ERR)
+    if ((retflag2 = eclipse_where(tret[5], ipl, starname, ifl, geopos, dcore, serr)) == SE_ERR)
       return retflag2;
     dc[2] = *dcore;
     /* the maximum is always total, and there is either one or
@@ -1902,10 +1902,10 @@ next_try:
   for (i = 0; i < 2; i++) {
     j = i + k;
     tt = tret[j] + swe_deltat_ex(tret[j], ifl, serr);
-    if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == ERR)
-        return ERR;
-    if (swe_calc(tt, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+    if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+    if (swe_calc(tt, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
     dc[i] = swe_degnorm(ls[0] - lm[0]);
     if (dc[i] > 180)
       dc[i] -= 360;
@@ -1923,10 +1923,10 @@ next_try:
         j++, dt /= 3) {
       for (i = 0, t = tjd; i <= 1; i++, t -= dt) {
         tt = t + swe_deltat_ex(t, ifl, serr);
-        if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == ERR)
-          return ERR;
-        if (swe_calc(tt, SE_MOON, iflag, lm, serr) == ERR)
-          return ERR;
+        if (calc_planet_star(tt, ipl, starname, iflag, ls, serr) == SE_ERR)
+          return SE_ERR;
+        if (swe_calc(tt, SE_MOON, iflag, lm, serr) == SE_ERR)
+          return SE_ERR;
         dc[i] = swe_degnorm(ls[0] - lm[0]);
         if (dc[i] > 180)
           dc[i] -= 360;
@@ -2000,7 +2000,7 @@ int32 CALL_CONV swe_sol_eclipse_when_loc(double tjd_start, int32 ifl,
   if (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for eclipses must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   ifl &= SEFLG_EPHMASK; 
   swi_set_tid_acc(tjd_start, ifl, 0, serr);
@@ -2009,7 +2009,7 @@ int32 CALL_CONV swe_sol_eclipse_when_loc(double tjd_start, int32 ifl,
   /* 
    * diameter of core shadow
    */
-  if ((retflag2 = eclipse_where(tret[0], SE_SUN, NULL, ifl, geopos2, dcore, serr)) == ERR)
+  if ((retflag2 = eclipse_where(tret[0], SE_SUN, NULL, ifl, geopos2, dcore, serr)) == SE_ERR)
     return retflag2;
   retflag |= (retflag2 & SE_ECL_NONCENTRAL);
   attr[3] = dcore[0];
@@ -2054,7 +2054,7 @@ int32 CALL_CONV swe_lun_occult_when_loc(double tjd_start, int32 ipl, char *starn
   if (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for occultations must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   if (ipl < 0) ipl = 0;
   if (ipl == SE_AST_OFFSET + 134340)
@@ -2066,7 +2066,7 @@ int32 CALL_CONV swe_lun_occult_when_loc(double tjd_start, int32 ipl, char *starn
   /* 
    * diameter of core shadow
    */
-  if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos2, dcore, serr)) == ERR)
+  if ((retflag2 = eclipse_where(tret[0], ipl, starname, ifl, geopos2, dcore, serr)) == SE_ERR)
     return retflag2;
   retflag |= (retflag2 & SE_ECL_NONCENTRAL);
   attr[3] = dcore[0];
@@ -2150,14 +2150,14 @@ next_try:
     for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
       /* this takes some time, but is necessary to avoid
        * missing an eclipse */
-      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_SUN, iflag, ls, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_SUN, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
       dm = sqrt(square_sum(xm));
       ds = sqrt(square_sum(xs));
       for (k = 0; k < 3; k++) {
@@ -2169,14 +2169,14 @@ next_try:
     find_maximum(dc[0], dc[1], dc[2], dt, &dtint, &dctr);
     tjd += dtint + dt;
   }
-  if (swe_calc(tjd, SE_SUN, iflagcart, xs, serr) == ERR)
-        return ERR;
-  if (swe_calc(tjd, SE_SUN, iflag, ls, serr) == ERR)
-        return ERR;
-  if (swe_calc(tjd, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
-  if (swe_calc(tjd, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+  if (swe_calc(tjd, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+  if (swe_calc(tjd, SE_SUN, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+  if (swe_calc(tjd, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
+  if (swe_calc(tjd, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
   dctr = acos(swi_dot_prod_unit(xs, xm)) * RADTODEG;
   rmoon = asin(RMOON / lm[2]) * RADTODEG;
   rsun = asin(RSUN / ls[2]) * RADTODEG;
@@ -2212,10 +2212,10 @@ next_try:
   else {
     dc[1] = fabs(rsminusrm) - dctrmin;
     for (i = 0, t = tjd - twomin; i <= 2; i += 2, t = tjd + twomin) {
-      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
+      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
       dm = sqrt(square_sum(xm));
       ds = sqrt(square_sum(xs));
       rmoon = asin(RMOON / dm) * RADTODEG;
@@ -2234,10 +2234,10 @@ next_try:
     tret[3] = tjd + dt2 + twomin;
     for (m = 0, dt = tensec; m < 2; m++, dt /= 10) {
       for (j = 2; j <= 3; j++) {
-        if (swe_calc(tret[j], SE_SUN, iflagcart | SEFLG_SPEED, xs, serr) == ERR)
-          return ERR;
-        if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == ERR)
-          return ERR;
+        if (swe_calc(tret[j], SE_SUN, iflagcart | SEFLG_SPEED, xs, serr) == SE_ERR)
+          return SE_ERR;
+        if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == SE_ERR)
+          return SE_ERR;
         for (i = 0; i < 2; i++) {
           if (i == 1) {
             for(k = 0; k < 3; k++) {
@@ -2268,10 +2268,10 @@ next_try:
   /* contacts 1 and 4 */
   dc[1] = rsplusrm - dctrmin;
   for (i = 0, t = tjd - twohr; i <= 2; i += 2, t = tjd + twohr) {
-    if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == ERR)
-      return ERR;
-    if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-      return ERR;
+    if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+      return SE_ERR;
+    if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+      return SE_ERR;
     dm = sqrt(square_sum(xm));
     ds = sqrt(square_sum(xs));
     rmoon = asin(RMOON / dm) * RADTODEG;
@@ -2289,10 +2289,10 @@ next_try:
   tret[4] = tjd + dt2 + twohr;
   for (m = 0, dt = tenmin; m < 3; m++, dt /= 10) {
     for (j = 1; j <= 4; j += 3) {
-      if (swe_calc(tret[j], SE_SUN, iflagcart | SEFLG_SPEED, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == ERR)
-        return ERR;
+      if (swe_calc(tret[j], SE_SUN, iflagcart | SEFLG_SPEED, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == SE_ERR)
+        return SE_ERR;
       for (i = 0; i < 2; i++) {
         if (i == 1) {
           for(k = 0; k < 3; k++) {
@@ -2325,8 +2325,8 @@ next_try:
     if (tret[i] == 0)
       continue;
     if (eclipse_how(tret[i], SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], 
-		attr, serr) == ERR)
-      return ERR;
+		attr, serr) == SE_ERR)
+      return SE_ERR;
     /*if (retflag2 & SE_ECL_VISIBLE) { could be wrong for 1st/4th contact */
     if (attr[6] > 0) {	/* this is safe, sun above horizon, using app. alt. */
       retflag |= SE_ECL_VISIBLE;
@@ -2349,12 +2349,12 @@ next_try:
     goto next_try;
   }
 #endif
-  if ((retc = swe_rise_trans(tret[1] - 0.001, SE_SUN, NULL, iflag, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == ERR)
-    return ERR;
+  if ((retc = swe_rise_trans(tret[1] - 0.001, SE_SUN, NULL, iflag, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == SE_ERR)
+    return SE_ERR;
   if (retc == -2) /* circumpolar sun */
     return retflag;
-  if ((retc = swe_rise_trans(tret[1] - 0.001, SE_SUN, NULL, iflag, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == ERR)
-    return ERR;
+  if ((retc = swe_rise_trans(tret[1] - 0.001, SE_SUN, NULL, iflag, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == SE_ERR)
+    return SE_ERR;
   if (retc == -2) /* circumpolar sun */
     return retflag;
   if (tjds < tret[1] || (tjds > tjdr && tjdr > tret[4])) {
@@ -2368,8 +2368,8 @@ next_try:
     tret[5] = tjdr;
     if (!(retflag & SE_ECL_MAX_VISIBLE)) {
       tret[0] = tjdr;
-      if ((retc = eclipse_how(tret[5], SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == ERR)
-	return ERR;
+      if ((retc = eclipse_how(tret[5], SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == SE_ERR)
+	return SE_ERR;
       retflag &= ~(SE_ECL_TOTAL|SE_ECL_ANNULAR|SE_ECL_PARTIAL);
       retflag |= (retc & (SE_ECL_TOTAL|SE_ECL_ANNULAR|SE_ECL_PARTIAL));
     }
@@ -2378,8 +2378,8 @@ next_try:
     tret[6] = tjds;
     if (!(retflag & SE_ECL_MAX_VISIBLE)) {
       tret[0] = tjds;
-      if ((retc = eclipse_how(tret[6], SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == ERR)
-	return ERR;
+      if ((retc = eclipse_how(tret[6], SE_SUN, NULL, ifl, geopos[0], geopos[1], geopos[2], attr, serr)) == SE_ERR)
+	return SE_ERR;
       retflag &= ~(SE_ECL_TOTAL|SE_ECL_ANNULAR|SE_ECL_PARTIAL);
       retflag |= (retc & (SE_ECL_TOTAL|SE_ECL_ANNULAR|SE_ECL_PARTIAL));
     }
@@ -2424,28 +2424,28 @@ static int32 occult_when_loc(
   tjd = tjd_start;
 next_try:
   //is_partial = FALSE;
-  if (calc_planet_star(t, ipl, starname, iflaggeo, ls, serr) == ERR)
-      return ERR;
+  if (calc_planet_star(t, ipl, starname, iflaggeo, ls, serr) == SE_ERR)
+      return SE_ERR;
   /* fixed stars with an ecliptic latitude > 7  or < -7 cannot have 
    * an occultation. Even lunar parallax andd proper motion of star
    * will never allow it. */
   if (fabs(ls[1]) > 7 && starname != NULL && *starname != '\0') {
     if (serr != NULL) 
       sprintf(serr, "occultation never occurs: star %s has ecl. lat. %.1f", starname, ls[1]);
-    return ERR;
+    return SE_ERR;
   }
-  if (swe_calc(t, SE_MOON, iflaggeo, lm, serr) == ERR)
-      return ERR;
+  if (swe_calc(t, SE_MOON, iflaggeo, lm, serr) == SE_ERR)
+      return SE_ERR;
   dl = swe_degnorm(ls[0] - lm[0]);
   if (direction < 0)
     dl -= 360;
   /* get rough conjunction in ecliptic longitude */
   while (fabs(dl) > 0.1) {
     t += dl / 13;
-    if (calc_planet_star(t, ipl, starname, iflaggeo, ls, serr) == ERR)
-	return ERR;
-    if (swe_calc(t, SE_MOON, iflaggeo, lm, serr) == ERR)
-	return ERR;
+    if (calc_planet_star(t, ipl, starname, iflaggeo, ls, serr) == SE_ERR)
+	return SE_ERR;
+    if (swe_calc(t, SE_MOON, iflaggeo, lm, serr) == SE_ERR)
+	return SE_ERR;
     dl = swe_degnorm(ls[0] - lm[0]);
     if (dl > 180) dl -= 360;
   }
@@ -2483,14 +2483,14 @@ next_try:
     for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
       /* this takes some time, but is necessary to avoid
        * missing an eclipse */
-      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (calc_planet_star(t, ipl, starname, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
       if (dt < 0.1 && fabs(ls[1] - lm[1]) > 2) {
         if (one_try || stop_after_this) {
           stop_after_this = TRUE;
@@ -2513,14 +2513,14 @@ next_try:
     tret[0] = tjd + direction;  /* return a date suitable for next try */
     return 0;
   }
-  if (calc_planet_star(tjd, ipl, starname, iflagcart, xs, serr) == ERR)
-        return ERR;
-  if (calc_planet_star(tjd, ipl, starname, iflag, ls, serr) == ERR)
-        return ERR;
-  if (swe_calc(tjd, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
-  if (swe_calc(tjd, SE_MOON, iflag, lm, serr) == ERR)
-        return ERR;
+  if (calc_planet_star(tjd, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+  if (calc_planet_star(tjd, ipl, starname, iflag, ls, serr) == SE_ERR)
+        return SE_ERR;
+  if (swe_calc(tjd, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
+  if (swe_calc(tjd, SE_MOON, iflag, lm, serr) == SE_ERR)
+        return SE_ERR;
   dctr = acos(swi_dot_prod_unit(xs, xm)) * RADTODEG;
   rmoon = asin(RMOON / lm[2]) * RADTODEG;
   rsun = asin(drad / ls[2]) * RADTODEG;
@@ -2563,10 +2563,10 @@ next_try:
   } else {
     dc[1] = fabs(rsminusrm) - dctrmin;
     for (i = 0, t = tjd - twomin; i <= 2; i += 2, t = tjd + twomin) {
-      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
+      if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
       dm = sqrt(square_sum(xm));
       ds = sqrt(square_sum(xs));
       rmoon = asin(RMOON / dm) * RADTODEG;
@@ -2585,10 +2585,10 @@ next_try:
     tret[3] = tjd + dt2 + twomin;
     for (m = 0, dt = tensec; m < 2; m++, dt /= 10) {
       for (j = 2; j <= 3; j++) {
-        if (calc_planet_star(tret[j], ipl, starname, iflagcart | SEFLG_SPEED, xs, serr) == ERR)
-          return ERR;
-        if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == ERR)
-          return ERR;
+        if (calc_planet_star(tret[j], ipl, starname, iflagcart | SEFLG_SPEED, xs, serr) == SE_ERR)
+          return SE_ERR;
+        if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == SE_ERR)
+          return SE_ERR;
         for (i = 0; i < 2; i++) {
           if (i == 1) {
             for(k = 0; k < 3; k++) {
@@ -2621,10 +2621,10 @@ next_try:
   dc[1] = rsplusrm - dctrmin;
 if (starname == NULL || *starname == '\0') {
   for (i = 0, t = tjd - twohr; i <= 2; i += 2, t = tjd + twohr) {
-    if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == ERR)
-      return ERR;
-    if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-      return ERR;
+    if (calc_planet_star(t, ipl, starname, iflagcart, xs, serr) == SE_ERR)
+      return SE_ERR;
+    if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+      return SE_ERR;
     dm = sqrt(square_sum(xm));
     ds = sqrt(square_sum(xs));
     rmoon = asin(RMOON / dm) * RADTODEG;
@@ -2642,10 +2642,10 @@ if (starname == NULL || *starname == '\0') {
   tret[4] = tjd + dt2 + twohr;
   for (m = 0, dt = tenmin; m < 3; m++, dt /= 10) {
     for (j = 1; j <= 4; j += 3) {
-      if (calc_planet_star(tret[j], ipl, starname, iflagcart | SEFLG_SPEED, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == ERR)
-        return ERR;
+      if (calc_planet_star(tret[j], ipl, starname, iflagcart | SEFLG_SPEED, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(tret[j], SE_MOON, iflagcart | SEFLG_SPEED, xm, serr) == SE_ERR)
+        return SE_ERR;
       for (i = 0; i < 2; i++) {
         if (i == 1) {
           for(k = 0; k < 3; k++) {
@@ -2682,8 +2682,8 @@ if (starname == NULL || *starname == '\0') {
     if (tret[i] == 0)
       continue;
     if (eclipse_how(tret[i], ipl, starname, ifl, geopos[0], geopos[1], geopos[2], 
-		attr, serr) == ERR)
-      return ERR;
+		attr, serr) == SE_ERR)
+      return SE_ERR;
     /*if (retflag2 & SE_ECL_VISIBLE) { could be wrong for 1st/4th contact */
     if (attr[6] > 0) {	/* this is save, sun above horizon (using app. alt.) */
       retflag |= SE_ECL_VISIBLE;
@@ -2709,10 +2709,10 @@ if (starname == NULL || *starname == '\0') {
     goto next_try;
   }
 #endif
-  if ((retc = swe_rise_trans(tret[1] - 0.1, ipl, starname, iflag, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == ERR)
-    return ERR;
-  if (retc >= 0 && (retc = swe_rise_trans(tret[1] - 0.1, ipl, starname, iflag, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == ERR)
-    return ERR;
+  if ((retc = swe_rise_trans(tret[1] - 0.1, ipl, starname, iflag, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == SE_ERR)
+    return SE_ERR;
+  if (retc >= 0 && (retc = swe_rise_trans(tret[1] - 0.1, ipl, starname, iflag, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == SE_ERR)
+    return SE_ERR;
   if (retc >= 0) {
     if (tjdr > tret[1] && tjdr < tret[4])
       tret[5] = tjdr;
@@ -2721,18 +2721,18 @@ if (starname == NULL || *starname == '\0') {
   }
   /* note, circumpolar sun above horizon is not tested */ 
   //if (!is_partial) {
-    if ((retc = swe_rise_trans(tret[1], SE_SUN, NULL, iflag, SE_CALC_RISE, geopos, 0, 0, &tjdr, serr)) == ERR)
-      return ERR;
-    if (retc >= 0 && (retc = swe_rise_trans(tret[1], SE_SUN, NULL, iflag, SE_CALC_SET, geopos, 0, 0, &tjds, serr)) == ERR)
-      return ERR;
+    if ((retc = swe_rise_trans(tret[1], SE_SUN, NULL, iflag, SE_CALC_RISE, geopos, 0, 0, &tjdr, serr)) == SE_ERR)
+      return SE_ERR;
+    if (retc >= 0 && (retc = swe_rise_trans(tret[1], SE_SUN, NULL, iflag, SE_CALC_SET, geopos, 0, 0, &tjds, serr)) == SE_ERR)
+      return SE_ERR;
     if (retc >= 0) {
       if (tjds < tjdr)
 	retflag |= SE_ECL_OCC_BEG_DAYLIGHT;
     } 
-    if ((retc = swe_rise_trans(tret[4], SE_SUN, NULL, iflag, SE_CALC_RISE, geopos, 0, 0, &tjdr, serr)) == ERR)
-      return ERR;
-    if (retc >= 0 && (retc = swe_rise_trans(tret[4], SE_SUN, NULL, iflag, SE_CALC_SET, geopos, 0, 0, &tjds, serr)) == ERR)
-      return ERR;
+    if ((retc = swe_rise_trans(tret[4], SE_SUN, NULL, iflag, SE_CALC_RISE, geopos, 0, 0, &tjdr, serr)) == SE_ERR)
+      return SE_ERR;
+    if (retc >= 0 && (retc = swe_rise_trans(tret[4], SE_SUN, NULL, iflag, SE_CALC_SET, geopos, 0, 0, &tjds, serr)) == SE_ERR)
+      return SE_ERR;
     if (retc >= 0) {
       if (tjds < tjdr)
 	retflag |= SE_ECL_OCC_END_DAYLIGHT;
@@ -3174,7 +3174,7 @@ int32 CALL_CONV swe_lun_eclipse_how(
   if (geopos != NULL && (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX)) {
     if (serr != NULL)
       sprintf(serr, "location for eclipses must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   ifl = ifl & ~SEFLG_TOPOCTR;
   ifl &= ~(SEFLG_JPLHOR | SEFLG_JPLHOR_APPROX);
@@ -3187,8 +3187,8 @@ int32 CALL_CONV swe_lun_eclipse_how(
    * azimuth and altitude of moon
    */
   swe_set_topo(geopos[0], geopos[1], geopos[2]);
-  if (swe_calc_ut(tjd_ut, SE_MOON, ifl | SEFLG_TOPOCTR | SEFLG_EQUATORIAL, lm, serr) == ERR)
-    return ERR;
+  if (swe_calc_ut(tjd_ut, SE_MOON, ifl | SEFLG_TOPOCTR | SEFLG_EQUATORIAL, lm, serr) == SE_ERR)
+    return SE_ERR;
   swe_azalt(tjd_ut, SE_EQU2HOR, geopos, 0, 10, lm, xaz);
   attr[4] = xaz[0];
   attr[5] = xaz[1];
@@ -3234,13 +3234,13 @@ static int32 lun_eclipse_how(
   deltat = swe_deltat_ex(tjd_ut, ifl, serr);
   tjd = tjd_ut + deltat;
   /* moon in cartesian coordinates */
-  if (swe_calc(tjd, SE_MOON, iflag, rm, serr) == ERR)
-    return ERR;
+  if (swe_calc(tjd, SE_MOON, iflag, rm, serr) == SE_ERR)
+    return SE_ERR;
   /* distance of moon from geocenter */
   dm = sqrt(square_sum(rm));
   /* sun in cartesian coordinates */
-  if (swe_calc(tjd, SE_SUN, iflag, rs, serr) == ERR)
-    return ERR;
+  if (swe_calc(tjd, SE_SUN, iflag, rs, serr) == SE_ERR)
+    return SE_ERR;
   /* distance of sun from geocenter */
   ds = sqrt(square_sum(rs));
   for (i = 0; i < 3; i++) {
@@ -3377,7 +3377,7 @@ int32 CALL_CONV swe_lun_eclipse_when(double tjd_start, int32 ifl, int32 ifltype,
       if (serr != NULL) {
         strcpy(serr, "annular lunar eclipses don't exist");
       }
-      return ERR; /* avoids infinite loop */
+      return SE_ERR; /* avoids infinite loop */
     }
   }
   if (ifltype == 0)
@@ -3459,10 +3459,10 @@ next_try:
        dt > 0.001; 
        j++, dt /= dtdiv) {
     for (i = 0, t = tjd - dt; i <= 2; i++, t += dt) {
-      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == ERR)
-        return ERR;
-      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == ERR)
-        return ERR;
+      if (swe_calc(t, SE_SUN, iflagcart, xs, serr) == SE_ERR)
+        return SE_ERR;
+      if (swe_calc(t, SE_MOON, iflagcart, xm, serr) == SE_ERR)
+        return SE_ERR;
       for (m = 0; m < 3; m++) {
         xs[m] -= xm[m];	/* selenocentric sun */
         xm[m] = -xm[m];	/* selenocentric earth */
@@ -3484,7 +3484,7 @@ next_try:
   tjd2 = tjd - swe_deltat_ex(tjd, ifl, serr);
   tjd2 = tjd - swe_deltat_ex(tjd2, ifl, serr);
   tjd = tjd - swe_deltat_ex(tjd2, ifl, serr);
-  if ((retflag = swe_lun_eclipse_how(tjd, ifl, NULL, attr, serr)) == ERR)
+  if ((retflag = swe_lun_eclipse_how(tjd, ifl, NULL, attr, serr)) == SE_ERR)
     return retflag;
   if (retflag == 0) {
     K += direction;
@@ -3537,7 +3537,7 @@ next_try:
     }
 #if 1
     for (i = 0, t = tjd - dta; i <= 2; i += 1, t += dta) {
-      if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) == ERR)
+      if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) == SE_ERR)
         return retflag2;
       if (n == 0)
         dc[i] = dcore[2] / 2 + RMOON / dcore[4] - dcore[0];
@@ -3557,7 +3557,7 @@ next_try:
     for (m = 0, dt = dtb / 2; m < 3; m++, dt /= 2) {
       for (j = i1; j <= i2; j += (i2 - i1)) {
         for (i = 0, t = tret[j] - dt; i < 2; i++, t += dt) {
-          if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) == ERR)
+          if ((retflag2 = lun_eclipse_how(t, ifl, attr, dcore, serr)) == SE_ERR)
             return retflag2;
           if (n == 0)
             dc[i] = dcore[2] / 2 + RMOON / dcore[4] - dcore[0];
@@ -3609,12 +3609,12 @@ int32 CALL_CONV swe_lun_eclipse_when_loc(double tjd_start, int32 ifl,
   if (geopos != NULL && (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX)) {
     if (serr != NULL)
       sprintf(serr, "location for eclipses must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   ifl &= ~(SEFLG_JPLHOR | SEFLG_JPLHOR_APPROX);
 next_lun_ecl:
-  if ((retflag = swe_lun_eclipse_when(tjd_start, ifl, 0, tret, backward, serr)) == ERR) {
-    return ERR;
+  if ((retflag = swe_lun_eclipse_when(tjd_start, ifl, 0, tret, backward, serr)) == SE_ERR) {
+    return SE_ERR;
   }
   /*  
    * visibility of eclipse phases 
@@ -3623,8 +3623,8 @@ next_lun_ecl:
   for (i = 7; i >= 0; i--) {
     if (i == 1) continue;
     if (tret[i] == 0) continue;
-    if ((retflag2 = swe_lun_eclipse_how(tret[i], ifl, geopos, attr, serr)) == ERR)
-      return ERR;
+    if ((retflag2 = swe_lun_eclipse_how(tret[i], ifl, geopos, attr, serr)) == SE_ERR)
+      return SE_ERR;
     if (attr[6] > 0) {  /* moon above horizon, using app. alt. */
       retflag |= SE_ECL_VISIBLE;
       switch(i) {
@@ -3648,10 +3648,10 @@ next_lun_ecl:
   }
   /* moon rise and moon set */
   tjd_max = tret[0];
-  if ((retc = swe_rise_trans(tret[6] - 0.001, SE_MOON, NULL, ifl, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == ERR)
-    return ERR;
-  if (retc >= 0 && (retc = swe_rise_trans(tret[6] - 0.001, SE_MOON, NULL, ifl, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == ERR)
-    return ERR;
+  if ((retc = swe_rise_trans(tret[6] - 0.001, SE_MOON, NULL, ifl, SE_CALC_RISE|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjdr, serr)) == SE_ERR)
+    return SE_ERR;
+  if (retc >= 0 && (retc = swe_rise_trans(tret[6] - 0.001, SE_MOON, NULL, ifl, SE_CALC_SET|SE_BIT_DISC_BOTTOM, geopos, 0, 0, &tjds, serr)) == SE_ERR)
+    return SE_ERR;
   if (retc >= 0) {
     if (tjds < tret[6] || (tjds > tjdr && tjdr > tret[7])) {
       if (backward)
@@ -3684,8 +3684,8 @@ next_lun_ecl:
     }
   }
   tret[0] = tjd_max;
-  if ((retflag2 = swe_lun_eclipse_how(tjd_max, ifl, geopos, attr, serr)) == ERR)
-    return ERR;
+  if ((retflag2 = swe_lun_eclipse_how(tjd_max, ifl, geopos, attr, serr)) == SE_ERR)
+    return SE_ERR;
   if (retflag2 == 0) {
     if (backward)
       tjd_start = tret[0] - 25;
@@ -3795,16 +3795,16 @@ int32 CALL_CONV swe_pheno(double tjd, int32 ipl, int32 iflag, double *attr, char
   /*  
    * geocentric planet
    */
-  if (swe_calc(tjd, (int) ipl, iflag | SEFLG_XYZ, xx, serr) == ERR)
+  if (swe_calc(tjd, (int) ipl, iflag | SEFLG_XYZ, xx, serr) == SE_ERR)
     /* int cast can be removed when swe_calc() gets int32 ipl definition */
-    return ERR;
-  if (swe_calc(tjd, (int) ipl, iflag, lbr, serr) == ERR)
+    return SE_ERR;
+  if (swe_calc(tjd, (int) ipl, iflag, lbr, serr) == SE_ERR)
     /* int cast can be removed when swe_calc() gets int32 ipl definition */
-    return ERR;
+    return SE_ERR;
   /* if moon, we need sun as well, for magnitude */
   if (ipl == SE_MOON)
-    if (swe_calc(tjd, SE_SUN, iflag | SEFLG_XYZ, xxs, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd, SE_SUN, iflag | SEFLG_XYZ, xxs, serr) == SE_ERR)
+      return SE_ERR;
   if (ipl != SE_SUN && ipl != SE_EARTH &&
     ipl != SE_MEAN_NODE && ipl != SE_TRUE_NODE &&
     ipl != SE_MEAN_APOG && ipl != SE_OSCU_APOG) {
@@ -3817,12 +3817,12 @@ int32 CALL_CONV swe_pheno(double tjd, int32 ipl, int32 iflag, double *attr, char
     /* 
      * heliocentric planet at tjd - dt
      */
-    if (swe_calc(tjd - dt, (int) ipl, iflagp | SEFLG_XYZ, xx2, serr) == ERR)
+    if (swe_calc(tjd - dt, (int) ipl, iflagp | SEFLG_XYZ, xx2, serr) == SE_ERR)
     /* int cast can be removed when swe_calc() gets int32 ipl definition */
-      return ERR;
-    if (swe_calc(tjd - dt, (int) ipl, iflagp, lbr2, serr) == ERR)
+      return SE_ERR;
+    if (swe_calc(tjd - dt, (int) ipl, iflagp, lbr2, serr) == SE_ERR)
     /* int cast can be removed when swe_calc() gets int32 ipl definition */
-      return ERR;
+      return SE_ERR;
     /*
      * phase angle
      */
@@ -3943,10 +3943,10 @@ int32 CALL_CONV swe_pheno(double tjd, int32 ipl, int32 iflag, double *attr, char
     /* 
      * elongation of planet
      */
-    if (swe_calc(tjd, SE_SUN, iflag | SEFLG_XYZ, xx2, serr) == ERR)
-      return ERR;
-    if (swe_calc(tjd, SE_SUN, iflag, lbr2, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd, SE_SUN, iflag | SEFLG_XYZ, xx2, serr) == SE_ERR)
+      return SE_ERR;
+    if (swe_calc(tjd, SE_SUN, iflag, lbr2, serr) == SE_ERR)
+      return SE_ERR;
     attr[2] = acos(swi_dot_prod_unit(xx, xx2)) * RADTODEG;
   }
   /* horizontal parallax */
@@ -3954,17 +3954,17 @@ int32 CALL_CONV swe_pheno(double tjd, int32 ipl, int32 iflag, double *attr, char
     double sinhp, xm[6];
     /* geocentric horizontal parallax */
     /* Expl.Suppl. to the AA 1984, p.400 */
-    if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_TRUEPOS|SEFLG_EQUATORIAL|SEFLG_RADIANS, xm, serr) == ERR)
+    if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_TRUEPOS|SEFLG_EQUATORIAL|SEFLG_RADIANS, xm, serr) == SE_ERR)
       /* int cast can be removed when swe_calc() gets int32 ipl definition */
-      return ERR;
+      return SE_ERR;
     sinhp = EARTH_RADIUS / xm[2] / AUNIT;
     attr[5] = asin(sinhp) / DEGTORAD;
     /* topocentric horizontal parallax */
     if (iflag & SEFLG_TOPOCTR) {
-      if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_XYZ|SEFLG_TOPOCTR, xm, serr) == ERR)
-	return ERR;
-      if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_XYZ, xx, serr) == ERR)
-	return ERR;
+      if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_XYZ|SEFLG_TOPOCTR, xm, serr) == SE_ERR)
+	return SE_ERR;
+      if (swe_calc(tjd, (int) ipl, epheflag|SEFLG_XYZ, xx, serr) == SE_ERR)
+	return SE_ERR;
       attr[5] = acos(swi_dot_prod_unit(xm, xx)) / DEGTORAD;
 #if 0
       {
@@ -4037,7 +4037,7 @@ static int find_zero(double y00, double y11, double y2, double dx,
   b = (y2 - y00) / 2.0;
   a = (y2 + y00) / 2.0 - c;
   if (b * b - 4 * a * c < 0) 
-    return ERR;
+    return SE_ERR;
   x1 = (-b + sqrt(b * b - 4 * a * c)) / 2 / a;
   x2 = (-b - sqrt(b * b - 4 * a * c)) / 2 / a;
   *dxret = (x1 - 1) * dx;
@@ -4115,8 +4115,8 @@ static int32 rise_set_fast(
     swe_set_topo(dgeo[0], dgeo[1], dgeo[2]);
   }
 run_rise_again:
-  if (swe_calc_ut(tjd_ut, ipl, iflagtopo, xx, serr) == ERR) 
-    return ERR;
+  if (swe_calc_ut(tjd_ut, ipl, iflagtopo, xx, serr) == SE_ERR) 
+    return SE_ERR;
   /* the diurnal arc is a bit fuzzy, 
    * - because the object changes declination during the day
    * - because there is refraction of light
@@ -4179,8 +4179,8 @@ run_rise_again:
     swe_set_topo(dgeo[0], dgeo[1], dgeo[2]);
   }
   for (i = 0; i < nloop; i++) {
-    if (swe_calc_ut(tr, ipl, iflagtopo, xx, serr) == ERR)
-      return ERR;
+    if (swe_calc_ut(tr, ipl, iflagtopo, xx, serr) == SE_ERR)
+      return SE_ERR;
     if (rsmi & SE_BIT_GEOCTR_NO_ECL_LAT)
       xx[1] = 0;
     rdi = get_sun_rad_plus_refr(ipl, xx[2], rsmi, refr); 
@@ -4289,7 +4289,7 @@ int ncalc = 0;
   if (geopos[2] < SEI_ECL_GEOALT_MIN || geopos[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for swe_rise_trans() must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   /*swi_set_tid_acc(tjd_ut, epheflag, 0, serr);*/
   /* function calls for Pluto with asteroid number 134340
@@ -4329,15 +4329,15 @@ int ncalc = 0;
    * western half of the sky for a short time. 
    */
   if (do_fixstar) {
-    if (swe_fixstar(starname, tjd_et, iflag, xc, serr) == ERR)
-      return ERR;
+    if (swe_fixstar(starname, tjd_et, iflag, xc, serr) == SE_ERR)
+      return SE_ERR;
   } 
   for (ii = 0, t = tjd_ut - twohrs; ii <= jmax; ii++, t += twohrs) {
     tc[ii] = t;
     if (!do_fixstar) {
       te = t + swe_deltat_ex(t, epheflag, serr);
-      if (swe_calc(te, ipl, iflag, xc, serr) == ERR)
-        return ERR;
+      if (swe_calc(te, ipl, iflag, xc, serr) == SE_ERR)
+        return SE_ERR;
 ncalc++;
     }
     if (rsmi & SE_BIT_GEOCTR_NO_ECL_LAT)
@@ -4408,8 +4408,8 @@ nazalt++;
         for (i = 0, tt = tcu - dt; i < 3; tt += dt, i++) {
           te = tt + swe_deltat_ex(tt, epheflag, serr);
           if (!do_fixstar)
-            if (swe_calc(te, ipl, iflag, xc, serr) == ERR)
-              return ERR;
+            if (swe_calc(te, ipl, iflag, xc, serr) == SE_ERR)
+              return SE_ERR;
 	    if (rsmi & SE_BIT_GEOCTR_NO_ECL_LAT)
 	      xc[1] = 0;
 ncalc++;
@@ -4439,8 +4439,8 @@ nazalt++;
         tc[j] = tculm[i];
         if (!do_fixstar) {
           te = tc[j] + swe_deltat_ex(tc[j], epheflag, serr);
-          if (swe_calc(te, ipl, iflag, xc, serr) == ERR)
-            return ERR;
+          if (swe_calc(te, ipl, iflag, xc, serr) == SE_ERR)
+            return SE_ERR;
 	  if (rsmi & SE_BIT_GEOCTR_NO_ECL_LAT)
 	    xc[1] = 0;
 ncalc++;
@@ -4501,8 +4501,8 @@ nazalt++;
       t = (t2[0] + t2[1]) / 2;
       if (!do_fixstar) {
         te = t + swe_deltat_ex(t, epheflag, serr);
-        if (swe_calc(te, ipl, iflag, xc, serr) == ERR)
-          return ERR;
+        if (swe_calc(te, ipl, iflag, xc, serr) == SE_ERR)
+          return SE_ERR;
 	if (rsmi & SE_BIT_GEOCTR_NO_ECL_LAT)
 	  xc[1] = 0;
 ncalc++;
@@ -4583,11 +4583,11 @@ static int32 calc_mer_trans(
     armc0 += 24;
   armc0 *= 15;
   if (do_fixstar) {
-    if (swe_fixstar(starname, tjd_et, iflag, x0, serr) == ERR)
-      return ERR;
+    if (swe_fixstar(starname, tjd_et, iflag, x0, serr) == SE_ERR)
+      return SE_ERR;
   } else {
-    if (swe_calc(tjd_et, ipl, iflag, x0, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_et, ipl, iflag, x0, serr) == SE_ERR)
+      return SE_ERR;
   }
   /*
    * meridian transits
@@ -4614,8 +4614,8 @@ static int32 calc_mer_trans(
       arxc = swe_degnorm(arxc + 180);
     if (!do_fixstar) {
       te = t + swe_deltat_ex(t, epheflag, serr);
-      if (swe_calc(te, ipl, iflag, x, serr) == ERR)
-	return ERR;
+      if (swe_calc(te, ipl, iflag, x, serr) == SE_ERR)
+	return SE_ERR;
     }
   }
   *tret = t;
@@ -5017,7 +5017,7 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
     if (xperi != NULL)
       for (i = 0; i <= 5; i++)
 	xperi[i] = 0;
-    return ERR;
+    return SE_ERR;
   }
   for (i = 0; i < 24; i++)
     xx[i] = 0;
@@ -5111,8 +5111,8 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
    ***************************************/
   } else {
     /* first, we need a heliocentric distance of the planet */
-    if (swe_calc(tjd_et, ipli, iflg0, x, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_et, ipli, iflg0, x, serr) == SE_ERR)
+      return SE_ERR;
     iflJ2000 = (iflag & SEFLG_EPHMASK)|SEFLG_J2000|SEFLG_EQUATORIAL|SEFLG_XYZ|SEFLG_TRUEPOS|SEFLG_NONUT|SEFLG_SPEED;
     ellipse_is_bary = FALSE;
     if (ipli != SE_MOON) {
@@ -5149,12 +5149,12 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
     for (i = istart, t = tjd_et - dt; i <= iend; i++, t += dt) {
       if (istart == iend)
         t = tjd_et;
-      if (swe_calc(t, ipli, iflJ2000, xpos[i], serr) == ERR)
-        return ERR;
+      if (swe_calc(t, ipli, iflJ2000, xpos[i], serr) == SE_ERR)
+        return SE_ERR;
       /* the EMB is used instead of the earth */
       if (ipli == SE_EARTH) {
-        if (swe_calc(t, SE_MOON, iflJ2000 & ~(SEFLG_BARYCTR|SEFLG_HELCTR), xposm, serr) == ERR)
-          return ERR;
+        if (swe_calc(t, SE_MOON, iflJ2000 & ~(SEFLG_BARYCTR|SEFLG_HELCTR), xposm, serr) == SE_ERR)
+          return SE_ERR;
         for (j = 0; j <= 5; j++)
           xpos[i][j] += xposm[j] / (EARTH_MOON_MRAT + 1.0);
       }
@@ -5266,11 +5266,11 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
    * we compute the planet */
   if (ipli == SE_MOON && (iflag & (SEFLG_HELCTR | SEFLG_BARYCTR))) {
     swi_force_app_pos_etc();
-    if (swe_calc(tjd_et, SE_SUN, iflg0, x, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_et, SE_SUN, iflg0, x, serr) == SE_ERR)
+      return SE_ERR;
   } else {
-    if (swe_calc(tjd_et, ipli, iflg0 | (iflag & SEFLG_TOPOCTR), x, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_et, ipli, iflg0 | (iflag & SEFLG_TOPOCTR), x, serr) == SE_ERR)
+      return SE_ERR;
   }
   /***********************
    * position of observer
@@ -5278,7 +5278,7 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
   if (iflag & SEFLG_TOPOCTR) {
     /* geocentric position of observer */
     if (swi_get_observer(tjd_et, iflag, FALSE, xobs, serr) != OK)
-      return ERR;
+      return SE_ERR;
     /*for (i = 0; i <= 5; i++)
       xobs[i] = swed.topd.xobs[i];*/
   } else {
@@ -5373,12 +5373,12 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
        */
       if (iflag & SEFLG_SPEED) {
         /* get barycentric sun and earth for t-dt into save area */
-        if (swe_calc(tjd_et - dt, ipli, iflg0 | (iflag & SEFLG_TOPOCTR), x2, serr) == ERR)
-          return ERR;
+        if (swe_calc(tjd_et - dt, ipli, iflg0 | (iflag & SEFLG_TOPOCTR), x2, serr) == SE_ERR)
+          return SE_ERR;
         if (iflag & SEFLG_TOPOCTR) {
           /* geocentric position of observer */
           /* if (swi_get_observer(tjd_et - dt, iflag, FALSE, xobs, serr) != OK)
-            return ERR;*/
+            return SE_ERR;*/
           for (i = 0; i <= 5; i++)
             xobs2[i] = swed.topd.xobs[i];
         } else {
@@ -5404,8 +5404,8 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
          * (i.e. bary sun, earth nutation matrix!). 
          * to restore it:
          */
-        if (swe_calc(tjd_et, SE_SUN, iflg0 | (iflag & SEFLG_TOPOCTR), x2, serr) == ERR)
-          return ERR;
+        if (swe_calc(tjd_et, SE_SUN, iflg0 | (iflag & SEFLG_TOPOCTR), x2, serr) == SE_ERR)
+          return SE_ERR;
       }
     }
     /*********************
@@ -5450,16 +5450,16 @@ int32 CALL_CONV swe_nod_aps(double tjd_et, int32 ipl, int32 iflag,
       /* project onto ecliptic t0 */
       if (swed.sidd.sid_mode & SE_SIDBIT_ECL_T0) {
         if (swi_trop_ra2sid_lon(x2000, pldat.xreturn+6, pldat.xreturn+18, iflag) != OK)
-          return ERR;
+          return SE_ERR;
       /* project onto solar system equator */
       } else if (swed.sidd.sid_mode & SE_SIDBIT_SSY_PLANE) {
         if (swi_trop_ra2sid_lon_sosy(x2000, pldat.xreturn+6, iflag) != OK)
-          return ERR;
+          return SE_ERR;
       } else {
       /* traditional algorithm */
         swi_cartpol_sp(pldat.xreturn+6, pldat.xreturn); 
-	if (swi_get_ayanamsa_ex(tjd_et, iflag, &daya, serr) == ERR)
-	  return ERR;
+	if (swi_get_ayanamsa_ex(tjd_et, iflag, &daya, serr) == SE_ERR)
+	  return SE_ERR;
         pldat.xreturn[0] -= daya * DEGTORAD;
         swi_polcart_sp(pldat.xreturn, pldat.xreturn+6); 
       }
@@ -5586,13 +5586,13 @@ static int32 get_gmsm(double tjd_et, int32 ipl, int32 iflag, double r, double *g
       plm = 0;
       if (iflag & SEFLG_ORBEL_AA) {
 	for (j = SE_MERCURY; j <= SE_PLUTO; j++) {
-	  if (swe_calc(tjd_et, j, iflJ2000p, x, serr) == ERR)
-	    return ERR;
+	  if (swe_calc(tjd_et, j, iflJ2000p, x, serr) == SE_ERR)
+	    return SE_ERR;
 	  if (r > x[2])
 	    plm += 1.0 / plmass[ipl_to_elem[j]];
 	}
-	if (swe_calc(tjd_et, SE_EARTH, iflJ2000p, x, serr) == ERR)
-	  return ERR;
+	if (swe_calc(tjd_et, SE_EARTH, iflJ2000p, x, serr) == SE_ERR)
+	  return SE_ERR;
 	if (r > x[2])
 	  plm += 1.0 / plmass[ipl_to_elem[SE_EARTH]];
       }
@@ -5665,13 +5665,13 @@ int32 CALL_CONV swe_get_orbital_elements(
   if (ipl <= 0 || ipl == SE_MEAN_NODE || ipl == SE_TRUE_NODE || ipl == SE_MEAN_APOG || ipl == SE_OSCU_APOG || ipl == SE_INTP_APOG || ipl == SE_INTP_PERG) {
     if (serr != NULL)
       sprintf(serr, "error in swe_get_orbital_elements(): object %d not valid\n", ipl);
-    return ERR;
+    return SE_ERR;
   }
   if (ipl != SE_MOON)
     iflg0 |= SEFLG_HELCTR;
   /* first, we need a heliocentric distance of the planet */
-  if (swe_calc(tjd_et, ipl, iflJ2000p, x, serr) == ERR)
-    return ERR;
+  if (swe_calc(tjd_et, ipl, iflJ2000p, x, serr) == SE_ERR)
+    return SE_ERR;
   r =  x[2];
   if (ipl != SE_MOON) {
     if ((iflag & SEFLG_BARYCTR) && r > 6) {
@@ -5681,13 +5681,13 @@ int32 CALL_CONV swe_get_orbital_elements(
     }
   }
   if (get_gmsm(tjd_et, ipl, iflag, r, &Gmsm, serr))
-    return ERR;
-  if (swe_calc(tjd_et, ipl, iflJ2000, xpos, serr) == ERR)
-    return ERR;
+    return SE_ERR;
+  if (swe_calc(tjd_et, ipl, iflJ2000, xpos, serr) == SE_ERR)
+    return SE_ERR;
   /* the EMB is used instead of the earth */
   if (ipl == SE_EARTH) {
-    if (swe_calc(tjd_et, SE_MOON, iflJ2000 & ~(SEFLG_BARYCTR|SEFLG_HELCTR), xposm, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_et, SE_MOON, iflJ2000 & ~(SEFLG_BARYCTR|SEFLG_HELCTR), xposm, serr) == SE_ERR)
+      return SE_ERR;
     for (j = 0; j <= 5; j++)
       xpos[j] += xposm[j] / (EARTH_MOON_MRAT + 1.0);
   }
@@ -5973,8 +5973,8 @@ static int32 orbit_max_min_true_distance_helio(double tjd_et, int ipl, int32 ifl
     ipli = SE_EARTH;
   }
   /* Kepler elements */
-  if ((retval = swe_get_orbital_elements(tjd_et, ipli, iflagi, de, serr)) == ERR)
-    return ERR;
+  if ((retval = swe_get_orbital_elements(tjd_et, ipli, iflagi, de, serr)) == SE_ERR)
+    return SE_ERR;
   *dmax = de[16];
   *dmin = de[15];
   osc_get_orbit_constants(de, pqri);
@@ -6048,10 +6048,10 @@ int32 CALL_CONV swe_orbit_max_min_true_distance(double tjd_et, int32 ipl, int32
     retval = orbit_max_min_true_distance_helio(tjd_et, ipl, iflagi, dmax, dmin, dtrue, serr);
     return retval;
   }
-  if ((retval = swe_get_orbital_elements(tjd_et, ipl, iflagi, dp, serr)) == ERR)
-    return ERR;
-  if ((retval = swe_get_orbital_elements(tjd_et, SE_EARTH, iflagi, de, serr)) == ERR)
-    return ERR;
+  if ((retval = swe_get_orbital_elements(tjd_et, ipl, iflagi, dp, serr)) == SE_ERR)
+    return SE_ERR;
+  if ((retval = swe_get_orbital_elements(tjd_et, SE_EARTH, iflagi, de, serr)) == SE_ERR)
+    return SE_ERR;
   if (de[0] > dp[0]) {
     douter = de;
     dinner = dp;
@@ -6200,7 +6200,7 @@ int32 CALL_CONV swe_gauquelin_sector(
   if (imeth < 0 || imeth > 5) {
     if (serr)
           sprintf(serr, "invalid method: %d", imeth);
-    return ERR;
+    return SE_ERR;
   }
   /* function calls for Pluto with asteroid number 134340
    * are treated as calls for Pluto as main body SE_PLUTO */
@@ -6217,11 +6217,11 @@ int32 CALL_CONV swe_gauquelin_sector(
     nutlo[1] *= RADTODEG;
     armc = swe_degnorm(swe_sidtime0(t_ut, eps + nutlo[1], nutlo[0]) * 15 + geopos[0]);
     if (do_fixstar) {
-      if (swe_fixstar(starname, t_et, iflag, x0, serr) == ERR)
-	return ERR;
+      if (swe_fixstar(starname, t_et, iflag, x0, serr) == SE_ERR)
+	return SE_ERR;
     } else {
-      if (swe_calc(t_et, ipl, iflag, x0, serr) == ERR)
-	return ERR;
+      if (swe_calc(t_et, ipl, iflag, x0, serr) == SE_ERR)
+	return SE_ERR;
     }
     if (imeth == 1) 
       x0[1] = 0;
@@ -6237,10 +6237,10 @@ int32 CALL_CONV swe_gauquelin_sector(
     risemeth |= SE_BIT_DISC_CENTER;
   /* find the next rising time of the planet or star */
   retval = swe_rise_trans(t_ut, ipl, starname, epheflag, SE_CALC_RISE|risemeth, geopos, atpress, attemp, &(tret[0]), serr);
-  if (retval == ERR) {
-    return ERR; 
+  if (retval == SE_ERR) {
+    return SE_ERR; 
   } else if (retval == -2) {
-    /* actually, we could return ERR here. However, we
+    /* actually, we could return SE_ERR here. However, we
      * keep this variable, in case we implement an algorithm
      * for Gauquelin sector positions of circumpolar bodies.
      * As with the Ludwig Otto procedure with Placidus, one 
@@ -6256,8 +6256,8 @@ int32 CALL_CONV swe_gauquelin_sector(
   }
   /* find the next setting time of the planet or star */
   retval = swe_rise_trans(t_ut, ipl, starname, epheflag, SE_CALC_SET|risemeth, geopos, atpress, attemp, &(tret[1]), serr);
-  if (retval == ERR) {
-    return ERR; 
+  if (retval == SE_ERR) {
+    return SE_ERR; 
   } else if (retval == -2) {
     set_found = FALSE;
   }
@@ -6268,8 +6268,8 @@ int32 CALL_CONV swe_gauquelin_sector(
     if (set_found) t = tret[1] - 1.2;
     set_found = TRUE;
     retval = swe_rise_trans(t, ipl, starname, epheflag, SE_CALC_SET|risemeth, geopos, atpress, attemp, &(tret[1]), serr);
-    if (retval == ERR) {
-      return ERR; 
+    if (retval == SE_ERR) {
+      return SE_ERR; 
     } else if (retval == -2) {
       set_found = FALSE;
     }
@@ -6280,8 +6280,8 @@ int32 CALL_CONV swe_gauquelin_sector(
     if (rise_found) t = tret[0] - 1.2;
     rise_found = TRUE;
     retval = swe_rise_trans(t, ipl, starname, epheflag, SE_CALC_RISE|risemeth, geopos, atpress, attemp, &(tret[0]), serr);
-    if (retval == ERR) {
-      return ERR; 
+    if (retval == SE_ERR) {
+      return SE_ERR; 
     } else if (retval == -2) {
       rise_found = FALSE;
     }
@@ -6297,6 +6297,6 @@ int32 CALL_CONV swe_gauquelin_sector(
     *dgsect = 0;
     if (serr)
       sprintf(serr, "rise or set not found for planet %d", ipl);
-    return ERR;
+    return SE_ERR;
   }
 }
diff --git a/src/libswe/swedate.c b/src/libswe/swedate.c
index 9743f55..fcd79a7 100644
--- a/src/libswe/swedate.c
+++ b/src/libswe/swedate.c
@@ -66,7 +66,7 @@
   This function converts some date+time input {d,m,y,uttime}
   into the Julian day number tjd.
   The function checks that the input is a legal combination
-  of dates; for illegal dates like 32 January 1993 it returns ERR
+  of dates; for illegal dates like 32 January 1993 it returns SE_ERR
   but still converts the date correctly, i.e. like 1 Feb 1993.
   The function is usually used to convert user input of birth data
   into the Julian day number. Illegal dates should be notified to the user.
@@ -80,7 +80,7 @@
   etc.
   Many users of Astro programs do not know about this difference.
 
-  Return: OK or ERR (for illegal date)
+  Return: OK or SE_ERR (for illegal date)
 *********************************************************/
 
 # include "swephexp.h"
@@ -108,7 +108,7 @@ int CALL_CONV swe_date_conversion(int y,
   if (rmon == m && rday == d && ryear == y) {
     return OK;
   } else {
-    return ERR;
+    return SE_ERR;
   }
 }	/* end date_conversion */
 
@@ -390,7 +390,7 @@ int32 CALL_CONV swe_utc_to_jd(int32 iyear, int32 imonth, int32 iday, int32 ihour
   if (iyear != iyear2 || imonth != imonth2 || iday != iday2) {
     if (serr != NULL)
       sprintf(serr, "invalid date: year = %d, month = %d, day = %d", iyear, imonth, iday);
-    return ERR;
+    return SE_ERR;
   }
   if (ihour < 0 || ihour > 23 
    || imin < 0 || imin > 59 
@@ -398,7 +398,7 @@ int32 CALL_CONV swe_utc_to_jd(int32 iyear, int32 imonth, int32 iday, int32 ihour
    || (dsec >= 60 && (imin < 59 || ihour < 23 || tjd_ut1 < J1972))) {
     if (serr != NULL)
       sprintf(serr, "invalid time: %d:%d:%.2f", ihour, imin, dsec);
-    return ERR;
+    return SE_ERR;
   }
   dhour = (double) ihour + ((double) imin) / 60.0 + dsec / 3600.0;
   /* 
@@ -453,7 +453,7 @@ int32 CALL_CONV swe_utc_to_jd(int32 iyear, int32 imonth, int32 iday, int32 ihour
     if (j != 1) {
       if (serr != NULL)
 	sprintf(serr, "invalid time (no leap second!): %d:%d:%.2f", ihour, imin, dsec);
-      return ERR;
+      return SE_ERR;
     }
   }
   /* 
diff --git a/src/libswe/swehel.c b/src/libswe/swehel.c
index 5fdb65d..de78a83 100644
--- a/src/libswe/swehel.c
+++ b/src/libswe/swehel.c
@@ -425,12 +425,12 @@ static int32 calc_rise_and_set(double tjd_start, int32 ipl, double *dgeo, double
   if (swe_calc_ut(tjd0, SE_SUN, iflag, xs, serr) == 0) {
     if (serr != NULL)
       strcpy(serr, "error in calc_rise_and_set(): calc(sun) failed ");
-    return ERR;
+    return SE_ERR;
   }
   if (swe_calc_ut(tjd0, ipl, iflag, xx, serr) == 0) {
     if (serr != NULL)
       strcpy(serr, "error in calc_rise_and_set(): calc(sun) failed ");
-    return ERR;
+    return SE_ERR;
   }
   tjdnoon -= swe_degnorm(xs[0] - xx[0])/360.0 + 0;
   /* is planet above horizon or below? */
@@ -453,10 +453,10 @@ if (eventflag & SE_CALC_RISE) {
   }
 }
   /* position of planet */
-  if (swe_calc_ut(tjdnoon, ipl, iflag, xx, serr) == ERR) {
+  if (swe_calc_ut(tjdnoon, ipl, iflag, xx, serr) == SE_ERR) {
     if (serr != NULL)
       strcpy(serr, "error in calc_rise_and_set(): calc(sun) failed ");
-    return ERR;
+    return SE_ERR;
   }
   /* apparent radius of solar disk (ignoring refraction) */
   rdi = 0;
@@ -487,9 +487,9 @@ else
   if (!(helflag & SE_HELFLAG_HIGH_PRECISION)) 
     iflag |= SEFLG_NONUT|SEFLG_TRUEPOS;
   for (i = 0; i < 2; i++) {
-    if (swe_calc_ut(tjdrise, ipl, iflag, xx, serr) == ERR) {
+    if (swe_calc_ut(tjdrise, ipl, iflag, xx, serr) == SE_ERR) {
       /*fprintf(stderr, "hev4 tjd=%f, ipl=%d, iflag=%d\n", tjdrise, ipl, iflag);*/
-      return ERR;
+      return SE_ERR;
     }
     swe_azalt(tjdrise, SE_EQU2HOR, dgeo, datm[0], datm[1], xx, xaz);
     xx[0] -= xx[3] * dfac; 
@@ -565,7 +565,7 @@ static double SunRA(double JDNDaysUT, int32 helflag, char *serr)
     int32 iflag = epheflag | SEFLG_EQUATORIAL;
     iflag |= SEFLG_NONUT | SEFLG_TRUEPOS;
     tjd_tt = JDNDaysUT + swe_deltat_ex(JDNDaysUT, epheflag, serr);
-    if (swe_calc(tjd_tt, SE_SUN, iflag, x, serr) != ERR) {
+    if (swe_calc(tjd_tt, SE_SUN, iflag, x, serr) != SE_ERR) {
       ralast = x[0];
       tjdlast = JDNDaysUT;
       return ralast;
@@ -692,11 +692,11 @@ static int32 ObjectLoc(double JDNDaysUT, double *dgeo, double *datm, char *Objec
   tjd_tt = JDNDaysUT + swe_deltat_ex(JDNDaysUT, epheflag, serr);
   Planet = DeterObject(ObjectName);
   if (Planet != -1) {
-    if (swe_calc(tjd_tt, Planet, iflag, x, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_tt, Planet, iflag, x, serr) == SE_ERR)
+      return SE_ERR;
   } else {
-    if (call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr) == ERR)
-      return ERR;
+    if (call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr) == SE_ERR)
+      return SE_ERR;
   }
   if (Angle == 2 ||  Angle == 5) {
     *dret = x[1];
@@ -745,11 +745,11 @@ static int32 azalt_cart(double JDNDaysUT, double *dgeo, double *datm, char *Obje
   tjd_tt = JDNDaysUT + swe_deltat_ex(JDNDaysUT, epheflag, serr);
   Planet = DeterObject(ObjectName);
   if (Planet != -1) {
-    if (swe_calc(tjd_tt, Planet, iflag, x, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjd_tt, Planet, iflag, x, serr) == SE_ERR)
+      return SE_ERR;
   } else {
-    if (call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr) == ERR)
-      return ERR;
+    if (call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr) == SE_ERR)
+      return SE_ERR;
   }
   xin[0] = x[0];
   xin[1] = x[1];
@@ -1113,12 +1113,12 @@ static int32 Magnitude(double JDNDaysUT, double *dgeo, char *ObjectName, int32 h
   if (Planet != -1) {
     /**dmag = Phenomena(JDNDaysUT, Lat, Longitude, HeightEye, TempE, PresE, ObjectName, 4);*/
     swe_set_topo(dgeo[0], dgeo[1], dgeo[2]);
-    if (swe_pheno_ut(JDNDaysUT, Planet, iflag, x, serr) == ERR)
-      return ERR;
+    if (swe_pheno_ut(JDNDaysUT, Planet, iflag, x, serr) == SE_ERR)
+      return SE_ERR;
     *dmag = x[4];
   } else {
-    if (call_swe_fixstar_mag(ObjectName, dmag, serr) == ERR)
-      return ERR;
+    if (call_swe_fixstar_mag(ObjectName, dmag, serr) == SE_ERR)
+      return SE_ERR;
   }
   return OK;
 }
@@ -1468,30 +1468,30 @@ int32 CALL_CONV swe_vis_limit_mag(double tjdut, double *dgeo, double *datm, doub
     if (serr != NULL) {
       strcpy(serr, "it makes no sense to call swe_vis_limit_mag() for the Sun");
     }
-    return ERR;
+    return SE_ERR;
   }
   swi_set_tid_acc(tjdut, helflag, 0, serr);
   sunra = SunRA(tjdut, helflag, serr);
   default_heliacal_parameters(datm, dgeo, dobs, helflag);
   swe_set_topo(dgeo[0], dgeo[1], dgeo[2]);
-  if (ObjectLoc(tjdut, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == ERR)
-    return ERR;
+  if (ObjectLoc(tjdut, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == SE_ERR)
+    return SE_ERR;
   if (AltO < 0) {
     if (serr != NULL)
       strcpy(serr, "object is below local horizon");
     *dret = -100;
     return -2;
   }
-  if (ObjectLoc(tjdut, dgeo, datm, ObjectName, 1, helflag, &AziO, serr) == ERR)
-    return ERR;
+  if (ObjectLoc(tjdut, dgeo, datm, ObjectName, 1, helflag, &AziO, serr) == SE_ERR)
+    return SE_ERR;
   if (helflag & SE_HELFLAG_VISLIM_DARK) {
     AltS = -90;
     AziS = 0;
   } else {
-    if (ObjectLoc(tjdut, dgeo, datm, "sun", 0, helflag, &AltS, serr) == ERR)
-      return ERR;
-    if (ObjectLoc(tjdut, dgeo, datm, "sun", 1, helflag, &AziS, serr) == ERR)
-      return ERR;
+    if (ObjectLoc(tjdut, dgeo, datm, "sun", 0, helflag, &AltS, serr) == SE_ERR)
+      return SE_ERR;
+    if (ObjectLoc(tjdut, dgeo, datm, "sun", 1, helflag, &AziS, serr) == SE_ERR)
+      return SE_ERR;
   }
   if (strncmp(ObjectName, "moon", 4) == 0 ||
       (helflag & SE_HELFLAG_VISLIM_DARK) ||
@@ -1499,10 +1499,10 @@ int32 CALL_CONV swe_vis_limit_mag(double tjdut, double *dgeo, double *datm, doub
      ) {
     AltM = -90; AziM = 0;
   } else {
-    if (ObjectLoc(tjdut, dgeo, datm, "moon", 0, helflag, &AltM, serr) == ERR)
-      return ERR;
-    if (ObjectLoc(tjdut, dgeo, datm, "moon", 1, helflag, &AziM, serr) == ERR)
-      return ERR;
+    if (ObjectLoc(tjdut, dgeo, datm, "moon", 0, helflag, &AltM, serr) == SE_ERR)
+      return SE_ERR;
+    if (ObjectLoc(tjdut, dgeo, datm, "moon", 1, helflag, &AziM, serr) == SE_ERR)
+      return SE_ERR;
   }
 #if DEBUG
 {
@@ -1526,12 +1526,12 @@ int32 CALL_CONV swe_vis_limit_mag(double tjdut, double *dgeo, double *datm, doub
   dret[4] = AziS;
   dret[5] = AltM;
   dret[6] = AziM;
-  if (Magnitude(tjdut, dgeo, ObjectName, helflag, &(dret[7]), serr) == ERR)
-    return ERR;
+  if (Magnitude(tjdut, dgeo, ObjectName, helflag, &(dret[7]), serr) == SE_ERR)
+    return SE_ERR;
   retval = scotopic_flag;
   /*dret[8] = (double) is_scotopic;*/
   /*if (*serr != '\0') * in VisLimMagn(), serr is only a warning *
-    retval = ERR; */
+    retval = SE_ERR; */
   return retval;
 }
 
@@ -1561,9 +1561,9 @@ static int32 TopoArcVisionis(double Magn, double *dobs, double AltO, double AziO
   double Xl = 45;
   double Yl, Yr;
   Yl = Magn - VisLimMagn(dobs, AltO, AziO, AltM, AziM, JDNDaysUT, AltO - Xl, AziS, sunra, Lat, HeightEye, datm, helflag, NULL, serr);
-  /* if (*serr != '\0') return ERR; * serr is only a warning */
+  /* if (*serr != '\0') return SE_ERR; * serr is only a warning */
   Yr = Magn - VisLimMagn(dobs, AltO, AziO, AltM, AziM, JDNDaysUT, AltO - xR, AziS, sunra, Lat, HeightEye, datm, helflag, NULL, serr);
-  /* if (*serr != '\0') return ERR; * serr is only a warning */
+  /* if (*serr != '\0') return SE_ERR; * serr is only a warning */
   /* http://en.wikipedia.org/wiki/Bisection_method*/
   if ((Yl * Yr) <= 0) {
     while(fabs(xR - Xl) > epsilon) {
@@ -1572,7 +1572,7 @@ static int32 TopoArcVisionis(double Magn, double *dobs, double AltO, double AziO
       AltSi = AltO - Xm;
       AziSi = AziS;
       Ym = Magn - VisLimMagn(dobs, AltO, AziO, AltM, AziM, JDNDaysUT, AltSi, AziSi, sunra, Lat, HeightEye, datm, helflag, NULL, serr);
-      /* if (*serr != '\0') return ERR; * serr is only a warning */
+      /* if (*serr != '\0') return SE_ERR; * serr is only a warning */
       if ((Yl * Ym) > 0) {
 	/* Throw away left half*/
 	Xl = Xm;
@@ -1599,7 +1599,7 @@ int32 CALL_CONV swe_topo_arcus_visionis(double tjdut, double *dgeo, double *datm
   swi_set_tid_acc(tjdut, helflag, 0, serr);
   sunra = SunRA(tjdut, helflag, serr);
   if (serr != NULL && *serr != '\0')
-    return ERR;
+    return SE_ERR;
   return TopoArcVisionis(mag, dobs, alt_obj, azi_obj, alt_moon, azi_moon, tjdut, azi_sun, sunra, dgeo[1], dgeo[2], datm, helflag, dret, serr);
 }
 
@@ -1645,8 +1645,8 @@ static int32 HeliacalAngle(double Magn, double *dobs, double AziO, double AltM,
   xmin = 0;
   ymin = 10000;
   for (x = minx; x <= maxx; x++) {
-    if (TopoArcVisionis(Magn, dobs, x, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Arc, serr) == ERR)
-      return ERR;
+    if (TopoArcVisionis(Magn, dobs, x, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Arc, serr) == SE_ERR)
+      return SE_ERR;
     if (Arc < ymin) {
       ymin = Arc;
       xmin = x;
@@ -1654,20 +1654,20 @@ static int32 HeliacalAngle(double Magn, double *dobs, double AziO, double AltM,
   }
   Xl = xmin - 1;
   xR = xmin + 1;
-  if (TopoArcVisionis(Magn, dobs, xR, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Yr, serr) == ERR)
-    return ERR;
-  if (TopoArcVisionis(Magn, dobs, Xl, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Yl, serr) == ERR)
-    return ERR;
+  if (TopoArcVisionis(Magn, dobs, xR, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Yr, serr) == SE_ERR)
+    return SE_ERR;
+  if (TopoArcVisionis(Magn, dobs, Xl, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Yl, serr) == SE_ERR)
+    return SE_ERR;
   /* http://en.wikipedia.org/wiki/Bisection_method*/
   while(fabs(xR - Xl) > 0.1) {
     /* Calculate midpoint of domain */
     Xm = (xR + Xl) / 2.0;
     DELTAx = 0.025;
     xmd = Xm + DELTAx;
-    if (TopoArcVisionis(Magn, dobs, Xm, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Ym, serr) == ERR)
-      return ERR;
-    if (TopoArcVisionis(Magn, dobs, xmd, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &ymd, serr) == ERR)
-      return ERR;
+    if (TopoArcVisionis(Magn, dobs, Xm, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &Ym, serr) == SE_ERR)
+      return SE_ERR;
+    if (TopoArcVisionis(Magn, dobs, xmd, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, Lat, HeightEye, datm, helflag, &ymd, serr) == SE_ERR)
+      return SE_ERR;
     if (Ym >= ymd) {
       /* Throw away left half */
       Xl = Xm;
@@ -1691,7 +1691,7 @@ int32 CALL_CONV swe_heliacal_angle(double tjdut, double *dgeo, double *datm, dou
   if (dgeo[2] < SEI_ECL_GEOALT_MIN || dgeo[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for heliacal events must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   swi_set_tid_acc(tjdut, helflag, 0, serr);
   return HeliacalAngle(mag, dobs, azi_obj, alt_moon, azi_moon, tjdut, azi_sun, dgeo, datm, helflag, dret, serr);
@@ -1753,25 +1753,25 @@ static int32 DeterTAV(double *dobs, double JDNDaysUT, double *dgeo, double *datm
 {
   double Magn, AltO, AziS, AziO, AziM, AltM;
   double sunra = SunRA(JDNDaysUT, helflag, serr);
-  if (Magnitude(JDNDaysUT, dgeo, ObjectName, helflag, &Magn, serr) == ERR)
-    return ERR;
-  if (ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == ERR)
-    return ERR;
-  if (ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 1, helflag, &AziO, serr) == ERR)
-    return ERR;
+  if (Magnitude(JDNDaysUT, dgeo, ObjectName, helflag, &Magn, serr) == SE_ERR)
+    return SE_ERR;
+  if (ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == SE_ERR)
+    return SE_ERR;
+  if (ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 1, helflag, &AziO, serr) == SE_ERR)
+    return SE_ERR;
   if (strncmp(ObjectName, "moon", 4) == 0) {
     AltM = -90; 
     AziM = 0;
   } else {
-    if (ObjectLoc(JDNDaysUT, dgeo, datm, "moon", 0, helflag, &AltM, serr) == ERR)
-      return ERR;
-    if (ObjectLoc(JDNDaysUT, dgeo, datm, "moon", 1, helflag, &AziM, serr) == ERR)
-      return ERR;
-  }
-  if (ObjectLoc(JDNDaysUT, dgeo, datm, "sun", 1, helflag, &AziS, serr) == ERR)
-    return ERR;
-  if (TopoArcVisionis(Magn, dobs, AltO, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, dgeo[1], dgeo[2], datm, helflag, dret, serr) == ERR)
-    return ERR;
+    if (ObjectLoc(JDNDaysUT, dgeo, datm, "moon", 0, helflag, &AltM, serr) == SE_ERR)
+      return SE_ERR;
+    if (ObjectLoc(JDNDaysUT, dgeo, datm, "moon", 1, helflag, &AziM, serr) == SE_ERR)
+      return SE_ERR;
+  }
+  if (ObjectLoc(JDNDaysUT, dgeo, datm, "sun", 1, helflag, &AziS, serr) == SE_ERR)
+    return SE_ERR;
+  if (TopoArcVisionis(Magn, dobs, AltO, AziO, AltM, AziM, JDNDaysUT, AziS, sunra, dgeo[1], dgeo[2], datm, helflag, dret, serr) == SE_ERR)
+    return SE_ERR;
   return OK;
 }
 
@@ -1867,7 +1867,7 @@ int32 CALL_CONV swe_heliacal_pheno_ut(double JDNDaysUT, double *dgeo, double *da
   if (dgeo[2] < SEI_ECL_GEOALT_MIN || dgeo[2] > SEI_ECL_GEOALT_MAX) {
     if (serr != NULL)
       sprintf(serr, "location for heliacal events must be between %.0f and %.0f m above sea", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   swi_set_tid_acc(JDNDaysUT, helflag, 0, serr);
   sunra = SunRA(JDNDaysUT, helflag, serr);
@@ -1886,15 +1886,15 @@ int32 CALL_CONV swe_heliacal_pheno_ut(double JDNDaysUT, double *dgeo, double *da
     retval = ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 0, helflag, &AltO, serr);
   if (retval == OK)
     retval = ObjectLoc(JDNDaysUT, dgeo, datm, ObjectName, 7, helflag, &GeoAltO, serr);
-  if (retval == ERR)
-    return ERR;
+  if (retval == SE_ERR)
+    return SE_ERR;
   AppAltO = AppAltfromTopoAlt(AltO, datm[1], datm[0], helflag);
   DAZact = AziS - AziO;
   TAVact = AltO - AltS;
   /*this parallax seems to be somewhat smaller then in Yallop and SkyMap! Needs to be studied*/
   ParO = GeoAltO - AltO;
-  if (Magnitude(JDNDaysUT, dgeo, ObjectName, helflag, &MagnO, serr) == ERR)
-    return ERR;
+  if (Magnitude(JDNDaysUT, dgeo, ObjectName, helflag, &MagnO, serr) == SE_ERR)
+    return SE_ERR;
   ARCVact = TAVact + ParO;
   ARCLact = acos(cos(ARCVact * DEGTORAD) * cos(DAZact * DEGTORAD)) / DEGTORAD;
   Planet = DeterObject(ObjectName);
@@ -1903,7 +1903,7 @@ int32 CALL_CONV swe_heliacal_pheno_ut(double JDNDaysUT, double *dgeo, double *da
     illum = 100;
   } else {
     retval = swe_pheno_ut(JDNDaysUT, Planet, iflag|(SEFLG_TOPOCTR|SEFLG_EQUATORIAL), attr, serr);
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
     elong = attr[2];
     illum = attr[1] * 100;
   }
@@ -1934,11 +1934,11 @@ darr[30] = darr[26] + darr[27] + darr[28] + darr[29];
   RS = 2;
   if (TypeEvent == 1 || TypeEvent == 4) RS = 1;
   retval = RiseSet(JDNDaysUT - 4.0 / 24.0, dgeo, datm, "sun", RS, helflag, 0, &RiseSetS, serr);
-  if (retval == ERR)
-    return ERR;
+  if (retval == SE_ERR)
+    return SE_ERR;
   retval = RiseSet(JDNDaysUT - 4.0 / 24.0, dgeo, datm, ObjectName, RS, helflag, 0, &RiseSetO, serr);
-  if (retval == ERR)
-    return ERR;
+  if (retval == SE_ERR)
+    return SE_ERR;
   TbYallop = TJD_INVALID;
   if (retval == -2) { /* object does not rise or set */
     Lag = 0;
@@ -1976,10 +1976,10 @@ darr[30] = darr[26] + darr[27] + darr[28] + darr[29];
       if (retval == OK)
 	retval = ObjectLoc(TimePointer, dgeo, datm, ObjectName, 0, helflag, &AltO2, serr);
       if (retval != OK)
-        return ERR;
+        return SE_ERR;
       DeltaAlt = AltO2 - AltS2;
-      if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVact, serr) == ERR)
-        return ERR;
+      if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVact, serr) == SE_ERR)
+        return SE_ERR;
       if (MinTAVoud < MinTAVact && TbVR == 0) {
         /* determine if this is a local minimum with object still above horizon*/
 	TimeCheck = TimePointer + Sgn(TimeStep) * LocalMinStep / 24.0 / 60.0;
@@ -1989,8 +1989,8 @@ darr[30] = darr[26] + darr[27] + darr[28] + darr[29];
 	  else
 	    TimeCheck = mymax(TimeCheck, RiseSetO);
 	}
-        if (DeterTAV(dobs, TimeCheck, dgeo, datm, ObjectName, helflag, &LocalminCheck, serr) == ERR)
-	  return ERR;
+        if (DeterTAV(dobs, TimeCheck, dgeo, datm, ObjectName, helflag, &LocalminCheck, serr) == SE_ERR)
+	  return SE_ERR;
 	if (LocalminCheck > MinTAVact) {
 	  extrax = x2min(MinTAVact, MinTAVoud, OldestMinTAV);
 	  TbVR = TimePointer - (1 - extrax) * TimeStep;
@@ -2119,12 +2119,12 @@ static int32 moon_event_arc_vis(double JDNDaysUTStart, double *dgeo, double *dat
   if (avkind != SE_HELFLAG_AVKIND_VR) {
     if (serr != NULL)
       strcpy(serr, "error: in valid AV kind for the moon");
-    return ERR;
+    return SE_ERR;
   }
   if (TypeEvent == 1 || TypeEvent == 2) {
     if (serr != NULL)
       strcpy(serr, "error: the moon has no morning first or evening last");
-    return ERR;
+    return SE_ERR;
   }
   strcpy(ObjectName, "moon");
   Planet = SE_MOON;
@@ -2174,16 +2174,16 @@ static int32 moon_event_arc_vis(double JDNDaysUTStart, double *dgeo, double *dat
       MinTAVoud = MinTAV;
       DeltaAltoud = DeltaAlt;
       tjd_moonevent = tjd_moonevent - 1.0 / 60.0 / 24.0 * Sgn(Daystep);
-      if (ObjectLoc(tjd_moonevent, dgeo, datm, "sun", 0, helflag, &AltS, serr) == ERR)
-	return ERR;
-      if (ObjectLoc(tjd_moonevent, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == ERR)
-	return ERR;
+      if (ObjectLoc(tjd_moonevent, dgeo, datm, "sun", 0, helflag, &AltS, serr) == SE_ERR)
+	return SE_ERR;
+      if (ObjectLoc(tjd_moonevent, dgeo, datm, ObjectName, 0, helflag, &AltO, serr) == SE_ERR)
+	return SE_ERR;
       DeltaAlt = AltO - AltS;
-      if (DeterTAV(dobs, tjd_moonevent, dgeo, datm, ObjectName, helflag, &MinTAV, serr) == ERR)
-        return ERR;
+      if (DeterTAV(dobs, tjd_moonevent, dgeo, datm, ObjectName, helflag, &MinTAV, serr) == SE_ERR)
+        return SE_ERR;
       TimeCheck = tjd_moonevent - LocalMinStep / 60.0 / 24.0 * Sgn(Daystep);
-      if (DeterTAV(dobs, TimeCheck, dgeo, datm, ObjectName, helflag, &LocalminCheck, serr) == ERR)
-        return ERR;
+      if (DeterTAV(dobs, TimeCheck, dgeo, datm, ObjectName, helflag, &LocalminCheck, serr) == SE_ERR)
+        return SE_ERR;
 /*printf("%f, %f <= %f\n", tjd_moonevent, MinTAV, MinTAVoud);*/
     /* while (MinTAV <= MinTAVoud && fabs(tjd_moonevent - tjd_moonevent_start) < 120.0 / 60.0 / 24.0);*/
     } while ((MinTAV <= MinTAVoud || LocalminCheck < MinTAV) && fabs(tjd_moonevent - tjd_moonevent_start) < 120.0 / 60.0 / 24.0);
@@ -2193,7 +2193,7 @@ static int32 moon_event_arc_vis(double JDNDaysUTStart, double *dgeo, double *dat
     tjd_moonevent += (1 - x2min(MinTAV, MinTAVoud, OldestMinTAV)) * Sgn(Daystep) / 60.0 / 24.0;
   } else {
     strcpy(serr, "no date found for lunar event");
-    return ERR;
+    return SE_ERR;
   }
   dret[0] = tjd_moonevent;
   return OK;
@@ -2223,7 +2223,7 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
   Pressure = datm[0];
   Temperature = datm[1];
   /* determine Magnitude of star*/
-  if ((retval = Magnitude(JDNDaysUTStart, dgeo, ObjectName, helflag, &objectmagn, serr)) == ERR)
+  if ((retval = Magnitude(JDNDaysUTStart, dgeo, ObjectName, helflag, &objectmagn, serr)) == SE_ERR)
     goto swe_heliacal_err;
   epheflag = helflag & (SEFLG_JPLEPH|SEFLG_SWIEPH|SEFLG_MOSEPH);
   iflag = SEFLG_TOPOCTR | SEFLG_EQUATORIAL | epheflag;
@@ -2282,11 +2282,11 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
 	ArcusVisDeltaoud = ArcusVisDelta;
 	JDNDaysUTstep = JDNDaysUTstep + DayStep;
 	/* determine rise/set time */
-	if ((retval = my_rise_trans(JDNDaysUTstep, SE_SUN, "", eventtype, helflag, dgeo, datm, &tret, serr)) == ERR)
+	if ((retval = my_rise_trans(JDNDaysUTstep, SE_SUN, "", eventtype, helflag, dgeo, datm, &tret, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
 	/* determine time compensation to get Sun's altitude at heliacal rise */
 	tjd_tt = tret + swe_deltat_ex(tret, epheflag, serr);
-	if ((retval = swe_calc(tjd_tt, SE_SUN, iflag, x, serr)) == ERR)
+	if ((retval = swe_calc(tjd_tt, SE_SUN, iflag, x, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
 	xin[0] = x[0];
 	xin[1] = x[1];
@@ -2302,7 +2302,7 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
 	JDNarcvisUT = tret - Tdelta / 24;
 	tjd_tt = JDNarcvisUT + swe_deltat_ex(JDNarcvisUT, epheflag, serr);
 	/* determine Sun's position */
-	if ((retval = swe_calc(tjd_tt, SE_SUN, iflag, x, serr)) == ERR)
+	if ((retval = swe_calc(tjd_tt, SE_SUN, iflag, x, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
 	xin[0] = x[0];
 	xin[1] = x[1];
@@ -2313,7 +2313,7 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
 	/* determine Moon's position */
 #if 0
   double AltM, AziM;
-	if ((retval = swe_calc(tjd_tt, SE_MOON, iflag, x, serr)) == ERR)
+	if ((retval = swe_calc(tjd_tt, SE_MOON, iflag, x, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
 	xin[0] = x[0];
 	xin[1] = x[1];
@@ -2324,13 +2324,13 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
 #endif
 	/* determine object's position */
 	if (Planet != -1) {
-	  if ((retval = swe_calc(tjd_tt, Planet, iflag, x, serr)) == ERR)
+	  if ((retval = swe_calc(tjd_tt, Planet, iflag, x, serr)) == SE_ERR)
 	    goto swe_heliacal_err;
 	  /* determine magnitude of Planet */
-	  if ((retval = Magnitude(JDNarcvisUT, dgeo, ObjectName, helflag, &objectmagn, serr)) == ERR)
+	  if ((retval = Magnitude(JDNarcvisUT, dgeo, ObjectName, helflag, &objectmagn, serr)) == SE_ERR)
 	    goto swe_heliacal_err;
 	} else {
-	  if ((retval = call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr)) == ERR)
+	  if ((retval = call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr)) == SE_ERR)
 	    goto swe_heliacal_err;
 	}
 	xin[0] = x[0];
@@ -2341,8 +2341,8 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
 	AltO = xaz[1];
 	/* determine arcusvisionis */
 	DeltaAlt = AltO - AltS;
-	/*if ((retval = HeliacalAngle(objectmagn, dobs, AziO, AltM, AziM, JDNarcvisUT, AziS, dgeo, datm, helflag, dang, serr)) == ERR)*/
-	if ((retval = HeliacalAngle(objectmagn, dobs, AziO, -1, 0, JDNarcvisUT, AziS, dgeo, datm, helflag, dang, serr)) == ERR)
+	/*if ((retval = HeliacalAngle(objectmagn, dobs, AziO, AltM, AziM, JDNarcvisUT, AziS, dgeo, datm, helflag, dang, serr)) == SE_ERR)*/
+	if ((retval = HeliacalAngle(objectmagn, dobs, AziO, -1, 0, JDNarcvisUT, AziS, dgeo, datm, helflag, dang, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
 	ArcusVis = dang[1];
 	ArcusVisPto = dang[2];
@@ -2368,7 +2368,7 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
   if (helflag & SE_HELFLAG_AVKIND_VR) {
     double darr[40];
     if (swe_heliacal_pheno_ut(JDNarcvisUT, dgeo, datm, dobs, ObjectName, TypeEvent, helflag, darr, serr) != OK)
-      return ERR;
+      return SE_ERR;
     JDNarcvisUT = darr[13];
     }
   }
@@ -2380,11 +2380,11 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
     TimeStep = direct;
     TbVR = 0;
     TimePointer = JDNarcvisUT;
-    if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &OldestMinTAV, serr) == ERR)
-      return ERR;
+    if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &OldestMinTAV, serr) == SE_ERR)
+      return SE_ERR;
     TimePointer = TimePointer + TimeStep;
-    if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVoud, serr) == ERR)
-      return ERR;
+    if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVoud, serr) == SE_ERR)
+      return SE_ERR;
     if (MinTAVoud > OldestMinTAV) {
       TimePointer = JDNarcvisUT;
       TimeStep = -TimeStep;
@@ -2398,8 +2398,8 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
       TimePointer = TimePointer + TimeStep;
       OldestMinTAV = MinTAVoud;
       MinTAVoud = MinTAVact;
-      if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVact, serr) == ERR)
-        return ERR;
+      if (DeterTAV(dobs, TimePointer, dgeo, datm, ObjectName, helflag, &MinTAVact, serr) == SE_ERR)
+        return SE_ERR;
       if (MinTAVoud < MinTAVact) {
 	extrax = x2min(MinTAVact, MinTAVoud, OldestMinTAV);
 	TbVR = TimePointer - (1 - extrax) * TimeStep;
@@ -2414,10 +2414,10 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
       JDNarcvisUT = JDNarcvisUT - direct;
       tjd_tt = JDNarcvisUT + swe_deltat_ex(JDNarcvisUT, epheflag, serr);
       if (Planet != -1) {
-	if ((retval = swe_calc(tjd_tt, Planet, iflag, x, serr)) == ERR)
+	if ((retval = swe_calc(tjd_tt, Planet, iflag, x, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
       } else {
-	if ((retval = call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr)) == ERR)
+	if ((retval = call_swe_fixstar(ObjectName, tjd_tt, iflag, x, serr)) == SE_ERR)
 	  goto swe_heliacal_err;
       }
       xin[0] = x[0];
@@ -2430,7 +2430,7 @@ static int32 heliacal_ut_arc_vis(double JDNDaysUTStart, double *dgeo, double *da
   if (JDNarcvisUT < -9999999 || JDNarcvisUT > 9999999) {
     dret[0] = JDNDaysUT; /* no date found, just return input */
     strcpy(serr, "no heliacal date found");
-    retval = ERR;
+    retval = SE_ERR;
     goto swe_heliacal_err;
   }
   dret[0] = JDNarcvisUT;
@@ -2450,11 +2450,11 @@ static int32 get_asc_obl(double tjd, int32 ipl, char *star, int32 iflag, double
   char star2[AS_MAXCH];
   strcpy(star2, star);
   if (ipl == -1) {
-    if ((retval = swe_fixstar(star2, tjd, epheflag | SEFLG_EQUATORIAL, x, serr)) == ERR)
-      return ERR;
+    if ((retval = swe_fixstar(star2, tjd, epheflag | SEFLG_EQUATORIAL, x, serr)) == SE_ERR)
+      return SE_ERR;
   } else {
-    if ((retval = swe_calc(tjd, ipl, epheflag | SEFLG_EQUATORIAL, x, serr)) == ERR)
-      return ERR;
+    if ((retval = swe_calc(tjd, ipl, epheflag | SEFLG_EQUATORIAL, x, serr)) == SE_ERR)
+      return SE_ERR;
   }
   adp = tan(dgeo[1] * DEGTORAD) * tan(x[1] * DEGTORAD);
   if (fabs(adp) > 1) {
@@ -2482,11 +2482,11 @@ static int32 get_asc_obl_old(double tjd, int32 ipl, char *star, int32 iflag, dou
   double x[6], adp;
   char s[AS_MAXCH];
   if (star != NULL && *star != '\0') {
-    if ((retval = call_swe_fixstar(star, tjd, epheflag | SEFLG_EQUATORIAL, x, serr)) == ERR)
-      return ERR;
+    if ((retval = call_swe_fixstar(star, tjd, epheflag | SEFLG_EQUATORIAL, x, serr)) == SE_ERR)
+      return SE_ERR;
   } else {
-    if ((retval = swe_calc(tjd, ipl, epheflag | SEFLG_EQUATORIAL, x, serr)) == ERR)
-      return ERR;
+    if ((retval = swe_calc(tjd, ipl, epheflag | SEFLG_EQUATORIAL, x, serr)) == SE_ERR)
+      return SE_ERR;
   }
   adp = tan(dgeo[1] * DEGTORAD) * tan(x[1] * DEGTORAD); 
   if (fabs(adp) > 1) {
@@ -2580,10 +2580,10 @@ static int32 find_conjunct_sun(double tjd_start, int32 ipl, int32 helflag, int32
   tjdcon = tjd0 + ((floor) ((tjd_start - tjd0) / dsynperiod) + 1) * dsynperiod;
   ds = 100;
   while (ds > 0.5) {
-    if (swe_calc(tjdcon, ipl, epheflag|SEFLG_SPEED, x, serr) == ERR)
-      return ERR;
-    if (swe_calc(tjdcon, SE_SUN, epheflag|SEFLG_SPEED, xs, serr) == ERR)
-      return ERR;
+    if (swe_calc(tjdcon, ipl, epheflag|SEFLG_SPEED, x, serr) == SE_ERR)
+      return SE_ERR;
+    if (swe_calc(tjdcon, SE_SUN, epheflag|SEFLG_SPEED, xs, serr) == SE_ERR)
+      return SE_ERR;
     ds = swe_degnorm(x[0] - xs[0] - daspect);
     if (ds > 180) ds -= 360;
     tjdcon -= ds / (x[3] - xs[3]);
@@ -2616,7 +2616,7 @@ static int32 get_asc_obl_with_sun(double tjd_start, int32 ipl, char *star, int32
   tjd = tjd_start;
   dsunpl_save = -999999999;
   retval = get_asc_obl_diff(tjd, ipl, star, epheflag, dgeo, desc_obl, is_acronychal, &dsunpl, serr);
-  if (retval != OK)  /* retval may be ERR or -2 */
+  if (retval != OK)  /* retval may be SE_ERR or -2 */
     return retval;
   daystep = 20;
   i = 0;
@@ -2628,28 +2628,28 @@ static int32 get_asc_obl_with_sun(double tjd_start, int32 ipl, char *star, int32
     i++;
     if (i > 5000) {
       sprintf(serr, "loop in get_asc_obl_with_sun() (1)");
-      return ERR;
+      return SE_ERR;
     }
     dsunpl_save = dsunpl;
     tjd += 10.0;
     if (dperiod > 0 && tjd - tjd_start > dperiod)
       return -2;
     retval = get_asc_obl_diff(tjd, ipl, star, epheflag, dgeo, desc_obl, is_acronychal, &dsunpl, serr);
-    if (retval != OK)  /* retval may be ERR or -2 */
+    if (retval != OK)  /* retval may be SE_ERR or -2 */
       return retval;
   }
   tjd_start = tjd - daystep;
   daystep /= 2.0;
   tjd = tjd_start + daystep;
   retval = get_asc_obl_diff(tjd, ipl, star, epheflag, dgeo, desc_obl, is_acronychal, &dsunpl_test, serr);
-  if (retval != OK)  /* retval may be ERR or -2 */
+  if (retval != OK)  /* retval may be SE_ERR or -2 */
     return retval;
   i = 0;
   while (fabs(dsunpl) > 0.00001) {
     i++;
     if (i > 5000) {
       sprintf(serr, "loop in get_asc_obl_with_sun() (2)");
-      return ERR;
+      return SE_ERR;
     }
     if (dsunpl_save * dsunpl_test >= 0) {
       dsunpl_save = dsunpl_test;
@@ -2660,7 +2660,7 @@ static int32 get_asc_obl_with_sun(double tjd_start, int32 ipl, char *star, int32
     daystep /= 2.0;
     tjd = tjd_start + daystep;
     retval = get_asc_obl_diff(tjd, ipl, star, epheflag, dgeo, desc_obl, is_acronychal, &dsunpl_test, serr);
-    if (retval != OK)  /* retval may be ERR or -2 */
+    if (retval != OK)  /* retval may be SE_ERR or -2 */
       return retval;
   }
   *tjdret = tjd;
@@ -2685,13 +2685,13 @@ static int32 get_asc_obl_with_sun_old(double tjd_start, int32 ipl, char *star, i
   daystep = dsynperiod;
   tjd = tjd_start;
   retval = get_asc_obl_diff(tjd, ipl, star, epheflag, dgeo, desc_obl, &dsunpl, serr);
-  if (retval != OK)  /* retval may be ERR or -2 */
+  if (retval != OK)  /* retval may be SE_ERR or -2 */
     return retval;
   while (dsunpl < 359.99999) {
     dsunpl_save = dsunpl;
     daystep /= 2.0;
     retval = get_asc_obl_diff(tjd + daystep, ipl, star, epheflag, dgeo, desc_obl, &dsunpl, serr);
-    if (retval != OK)  /* retval may be ERR or -2 */
+    if (retval != OK)  /* retval may be SE_ERR or -2 */
       return retval;
     if (dsunpl > dsunpl_save)
       tjd += daystep;
@@ -2721,11 +2721,11 @@ static int32 get_asc_obl_acronychal(double tjd_start, int32 ipl, char *star, int
   }
   /* ascensio (descensio) obliqua of sun */
   retval = get_asc_obl(tjd, SE_SUN, "", epheflag, dgeo, sun_desc, &aosun, serr);
-  if (retval != OK)  /* retval may be ERR or -2 */
+  if (retval != OK)  /* retval may be SE_ERR or -2 */
     return retval;
   /* ascensio (descensio) obliqua of body */
   retval = get_asc_obl(tjd, ipl, star, epheflag, dgeo, obj_desc, &aopl, serr);
-  if (retval != OK)  /* retval may be ERR or -2 */
+  if (retval != OK)  /* retval may be SE_ERR or -2 */
     return retval;
   dsunpl = swe_degnorm(aosun - aopl + 180);
   while (dsunpl < 359.99999) {
@@ -2733,11 +2733,11 @@ static int32 get_asc_obl_acronychal(double tjd_start, int32 ipl, char *star, int
     daystep /= 2.0;
     /* ascensio (descensio) obliqua of sun */
     retval = get_asc_obl(tjd+daystep, SE_SUN, "", epheflag, dgeo, sun_desc, &aosun, serr);
-    if (retval != OK)  /* retval may be ERR or -2 */
+    if (retval != OK)  /* retval may be SE_ERR or -2 */
       return retval;
     /* ascensio (descensio) obliqua of body */
     retval = get_asc_obl(tjd+daystep, ipl, star, epheflag, dgeo, obj_desc, &aopl, serr);
-    if (retval != OK)  /* retval may be ERR or -2 */
+    if (retval != OK)  /* retval may be SE_ERR or -2 */
       return retval;
     dsunpl = swe_degnorm(aosun - aopl + 180);
     if (dsunpl > dsunpl_save)
@@ -2808,8 +2808,8 @@ static int32 get_heliacal_day(double tjd, double *dgeo, double *datm, double *do
       break; 
     case -1:
       ndays = 300;
-      if (call_swe_fixstar_mag(ObjectName, &dmag, serr) == ERR) {
-	return ERR;
+      if (call_swe_fixstar_mag(ObjectName, &dmag, serr) == SE_ERR) {
+	return SE_ERR;
       }
       daystep = 15;
       tfac = 10;
@@ -2834,8 +2834,8 @@ static int32 get_heliacal_day(double tjd, double *dgeo, double *datm, double *do
     vdelta = -100; 
     if (i > 0)
       tday -= 0.3 * direct_day;
-    if ((retval = my_rise_trans(tday, SE_SUN, "", is_rise_or_set, helflag, dgeo, datm, &tret, serr)) == ERR) {
-      return ERR;
+    if ((retval = my_rise_trans(tday, SE_SUN, "", is_rise_or_set, helflag, dgeo, datm, &tret, serr)) == SE_ERR) {
+      return SE_ERR;
     }
     /* sun does not rise: try next day */
     if (retval == -2) {
@@ -2843,8 +2843,8 @@ static int32 get_heliacal_day(double tjd, double *dgeo, double *datm, double *do
       continue;
     }
     retval = swe_vis_limit_mag(tret, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-    if (retval == ERR)
-      return ERR;
+    if (retval == SE_ERR)
+      return SE_ERR;
 #if 1
     /*  object has appeared above horizon: reduce daystep */
     if (retval_old == -2 && retval >= 0 && daystep > 1) {
@@ -2881,8 +2881,8 @@ static int32 get_heliacal_day(double tjd, double *dgeo, double *datm, double *do
       else 
 	tret += 1.0 / div * direct_time;
       retval = swe_vis_limit_mag(tret, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-      if (retval == ERR)
-	return ERR;
+      if (retval == SE_ERR)
+	return SE_ERR;
     }
     /* if possible move a bit away from sunset, where vis_limit_mag() has strange behaviour */
     if (visible_at_sunsetrise) {
@@ -2919,7 +2919,7 @@ static int32 time_optimum_visibility(double tjd, double *dgeo, double *datm, dou
   int t_has_changed;
   *tret = tjd;
   retval = swe_vis_limit_mag(tjd, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-  if (retval == ERR) return ERR;
+  if (retval == SE_ERR) return SE_ERR;
   retval_sv = retval;
   //vl = darr[0] - darr[7];
   //vl = -1;
@@ -2945,7 +2945,7 @@ static int32 time_optimum_visibility(double tjd, double *dgeo, double *datm, dou
     }
     if (t_has_changed == 0)
       t1 -= d; /* revert initial addition */
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
   }
   for (i = 0, d = 100.0 / 86400.0; i < 3; i++, d /= 10.0) {
     t2 -= d;
@@ -2962,7 +2962,7 @@ static int32 time_optimum_visibility(double tjd, double *dgeo, double *datm, dou
     }
     if (t_has_changed == 0)
       t2 += d; /* revert initial subtraction */
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
   }
   if (vl2 > vl1) 
     tjd = t2;
@@ -2999,7 +2999,7 @@ static int32 time_limit_invisible(double tjd, double *dgeo, double *datm, double
     ncnt = 4;
   }
   retval = swe_vis_limit_mag(tjd + d * direct, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-  if (retval == ERR) return ERR;
+  if (retval == SE_ERR) return SE_ERR;
   retval_sv = retval;
   phot_scot_opic_sv = retval & SE_SCOTOPIC_FLAG;
   for (i = 0, d = d0; i < ncnt; i++, d /= 10.0) {
@@ -3061,30 +3061,30 @@ static int32 get_acronychal_day(double tjd, double *dgeo, double *datm, double *
     tjd += 0.7 * direct;
     if (direct < 0) tjd -= 1;
     retval = my_rise_trans(tjd, ipl, ObjectName, is_rise_or_set, helflag, dgeo, datm, &tjd, serr);
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
     retval = swe_vis_limit_mag(tjd, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
     while(darr[0] < darr[7]) {
       tjd += 10.0 / 1440.0 * -direct;
       retval = swe_vis_limit_mag(tjd, dgeo, datm, dobs, ObjectName, helflag, darr, serr);
-      if (retval == ERR) return ERR;
+      if (retval == SE_ERR) return SE_ERR;
     }
     retval = time_limit_invisible(tjd, dgeo, datm, dobs, ObjectName, helflag | SE_HELFLAG_VISLIM_DARK, direct, &tret_dark, serr);
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
     retval = time_limit_invisible(tjd, dgeo, datm, dobs, ObjectName, helflag | SE_HELFLAG_VISLIM_NOMOON, direct, &tret, serr);
-    if (retval == ERR) return ERR;
+    if (retval == SE_ERR) return SE_ERR;
 #if 0
-    if (azalt_cart(tret_dark, dgeo, datm, ObjectName, helflag, darr, serr) == ERR)
-      return ERR;
-    if (azalt_cart(tret, dgeo, datm, ObjectName, helflag, darr+6, serr) == ERR)
-      return ERR;
+    if (azalt_cart(tret_dark, dgeo, datm, ObjectName, helflag, darr, serr) == SE_ERR)
+      return SE_ERR;
+    if (azalt_cart(tret, dgeo, datm, ObjectName, helflag, darr+6, serr) == SE_ERR)
+      return SE_ERR;
     dtret = acos(swi_dot_prod_unit(darr+3, darr+9)) / DEGTORAD;
 #else
     dtret = fabs(tret - tret_dark);
 #endif
   }
-  if (azalt_cart(tret, dgeo, datm, "sun", helflag, darr, serr) == ERR)
-    return ERR;
+  if (azalt_cart(tret, dgeo, datm, "sun", helflag, darr, serr) == SE_ERR)
+    return SE_ERR;
   *thel = tret;
   if (darr[1] < -12) {
     sprintf(serr, "acronychal rising/setting not available, %f", darr[1]);
@@ -3102,7 +3102,7 @@ static int32 get_heliacal_details(double tday, double *dgeo, double *datm, doubl
   /* find next optimum visibility */
   optimum_undefined = FALSE;
   retval = time_optimum_visibility(tday, dgeo, datm, dobs, ObjectName, helflag, &(dret[1]), serr);
-  if (retval == ERR) return ERR;
+  if (retval == SE_ERR) return SE_ERR;
   if (retval == -2) {
     retval = OK;
     optimum_undefined = TRUE; /* change photopic <-> scotopic vision */
@@ -3113,7 +3113,7 @@ static int32 get_heliacal_details(double tday, double *dgeo, double *datm, doubl
     direct = -1;
   limit_1_undefined = FALSE;
   retval = time_limit_invisible(tday, dgeo, datm, dobs, ObjectName, helflag, direct, &(dret[0]), serr);
-  if (retval == ERR) return ERR;
+  if (retval == SE_ERR) return SE_ERR;
   if (retval == -2) {
     retval = OK;
     limit_1_undefined = TRUE; /* change photopic <-> scotopic vision */
@@ -3122,7 +3122,7 @@ static int32 get_heliacal_details(double tday, double *dgeo, double *datm, doubl
   direct *= -1;
   limit_2_undefined = FALSE;
   retval = time_limit_invisible(dret[1], dgeo, datm, dobs, ObjectName, helflag, direct, &(dret[2]), serr);
-  if (retval == ERR) return ERR;
+  if (retval == SE_ERR) return SE_ERR;
   if (retval == -2) {
     retval = OK;
     limit_2_undefined = TRUE; /* change photopic <-> scotopic vision */
@@ -3183,10 +3183,10 @@ static int32 heliacal_ut_vis_lim(double tjd_start, double *dgeo, double *datm, d
       /* find date when star rises with sun (cosmic rising) */
     retval = get_asc_obl_with_sun(tjd, ipl, ObjectName, helflag, TypeEvent, 0, dgeo, &tjd, serr);
       if (retval != OK)
-	goto swe_heliacal_err; /* retval may be -2 or ERR */
+	goto swe_heliacal_err; /* retval may be -2 or SE_ERR */
     } else {
       /* find date of conjunction of object with sun */
-      if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == ERR) {
+      if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == SE_ERR) {
 	goto swe_heliacal_err;
       }
     }
@@ -3205,7 +3205,7 @@ static int32 heliacal_ut_vis_lim(double tjd_start, double *dgeo, double *datm, d
 	goto swe_heliacal_err;
     } else {
       /* find date of conjunction of object with sun */
-      if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == ERR)
+      if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == SE_ERR)
 	goto swe_heliacal_err;
     }
     tday = tjd;
@@ -3221,7 +3221,7 @@ static int32 heliacal_ut_vis_lim(double tjd_start, double *dgeo, double *datm, d
      */
     if (ipl == SE_MERCURY || ipl == SE_VENUS || TypeEvent <= 2) {
       retval = get_heliacal_details(tday, dgeo, datm, dobs, ObjectName, TypeEvent, helflag2, dret, serr);
-      if (retval == ERR) goto swe_heliacal_err;
+      if (retval == SE_ERR) goto swe_heliacal_err;
     } else if (0) {
       if (TypeEvent == 4 || TypeEvent == 6) direct = -1;
       for (i = 0, d = 100.0 / 86400.0; i < 3; i++, d /= 10.0) {
@@ -3252,7 +3252,7 @@ static int32 moon_event_vis_lim(double tjdstart, double *dgeo, double *datm, dou
   if (TypeEvent == 1 || TypeEvent == 2) {
     if (serr_ret != NULL)
       strcpy(serr_ret, "error: the moon has no morning first or evening last");
-    return ERR;
+    return SE_ERR;
   }
   strcpy(ObjectName, "moon");
   ipl = SE_MOON;
@@ -3264,8 +3264,8 @@ static int32 moon_event_vis_lim(double tjdstart, double *dgeo, double *datm, dou
   /* check Synodic/phase Period */
   tjd = tjdstart - 30; /* -50 makes sure, that no event is missed, 
                          * but may return an event before start date */
-  if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == ERR)
-    return ERR;
+  if ((retval = find_conjunct_sun(tjd, ipl, helflag, TypeEvent, &tjd, serr)) == SE_ERR)
+    return SE_ERR;
   /* find the day and minute on which the object becomes visible */
   retval = get_heliacal_day(tjd, dgeo, datm, dobs, ObjectName, helflag2, TypeEvent, &tjd, serr); 
   if (retval != OK)
@@ -3273,7 +3273,7 @@ static int32 moon_event_vis_lim(double tjdstart, double *dgeo, double *datm, dou
   dret[0] = tjd;
   /* find next optimum visibility */
   retval = time_optimum_visibility(tjd, dgeo, datm, dobs, ObjectName, helflag, &tjd, serr);
-  if (retval == ERR) goto moon_event_err;
+  if (retval == SE_ERR) goto moon_event_err;
   dret[1] = tjd;
   /* find moment of becoming visible */
   /* Note: On the day of first light the moon may become visible 
@@ -3283,18 +3283,18 @@ static int32 moon_event_vis_lim(double tjdstart, double *dgeo, double *datm, dou
   if (TypeEvent == 4)
     direct = -1;
   retval = time_limit_invisible(tjd, dgeo, datm, dobs, ObjectName, helflag, direct, &tjd, serr);
-  if (retval == ERR) goto moon_event_err;
+  if (retval == SE_ERR) goto moon_event_err;
   dret[2] = tjd;
   /* find moment of end of visibility */
   direct *= -1;
   retval = time_limit_invisible(dret[1], dgeo, datm, dobs, ObjectName, helflag, direct, &tjd, serr);
   dret[0] = tjd;
-  if (retval == ERR) goto moon_event_err;
+  if (retval == SE_ERR) goto moon_event_err;
 #if 1
   /* if the moon is visible before sunset, we return sunset as start time */
   if (TypeEvent == 3) {
-    if ((retval = my_rise_trans(tjd, SE_SUN, "", SE_CALC_SET, helflag, dgeo, datm, &trise, serr)) == ERR)
-      return ERR;
+    if ((retval = my_rise_trans(tjd, SE_SUN, "", SE_CALC_SET, helflag, dgeo, datm, &trise, serr)) == SE_ERR)
+      return SE_ERR;
     if (trise < dret[1]) {
       dret[0] = trise;
       /* do not warn, it happens too often */
@@ -3302,8 +3302,8 @@ static int32 moon_event_vis_lim(double tjdstart, double *dgeo, double *datm, dou
     }
   /* if the moon is visible after sunrise, we return sunrise as end time */
   } else {
-    if ((retval = my_rise_trans(dret[1], SE_SUN, "", SE_CALC_RISE, helflag, dgeo, datm, &trise, serr)) == ERR)
-      return ERR;
+    if ((retval = my_rise_trans(dret[1], SE_SUN, "", SE_CALC_RISE, helflag, dgeo, datm, &trise, serr)) == SE_ERR)
+      return SE_ERR;
     if (dret[0] > trise) {
       dret[0] = trise;
       /* do not warn, it happens too often */
@@ -3381,7 +3381,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
   if (dgeo[2] < SEI_ECL_GEOALT_MIN || dgeo[2] > SEI_ECL_GEOALT_MAX) {
     if (serr_ret != NULL)
       sprintf(serr_ret, "location for heliacal events must be between %.0f and %.0f m above sea\n", SEI_ECL_GEOALT_MIN, SEI_ECL_GEOALT_MAX);
-    return ERR;
+    return SE_ERR;
   }
   swi_set_tid_acc(JDNDaysUTStart, helflag, 0, serr);
   if (helflag & SE_HELFLAG_LONG_SEARCH)
@@ -3402,7 +3402,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
     if (serr_ret != NULL) {
       strcpy(serr_ret, "the sun has no heliacal rising or setting\n");
     }
-    return ERR;
+    return SE_ERR;
   }
   /* 
    * Moon events
@@ -3412,7 +3412,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
       if (serr_ret != NULL) {
         sprintf(serr_ret, "%s (event type %d) does not exist for the moon\n", sevent[TypeEvent], TypeEvent);
       }
-      return ERR;
+      return SE_ERR;
     }
     tjd = tjd0;
     retval = MoonEventJDut(tjd, dgeo, datm, dobs, TypeEvent, helflag, dret, serr);
@@ -3438,7 +3438,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
 	    swe_get_planet_name(Planet, s);
 	  sprintf(serr_ret, "%s (event type %d) does not exist for %s\n", sevent[TypeEvent], TypeEvent, s);
 	}
-	return ERR;
+	return SE_ERR;
       }
     }
   }
@@ -3461,7 +3461,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
 	  swe_get_planet_name(Planet, s);
 	sprintf(serr_ret, "%s (event type %d) is not provided for %s\n", sevent[TypeEvent], TypeEvent, s);
       }
-      return ERR;
+      return SE_ERR;
     }
   }
   dsynperiod = get_synodic_period(Planet);
@@ -3496,7 +3496,7 @@ int32 CALL_CONV swe_heliacal_ut(double JDNDaysUTStart, double *dgeo, double *dat
     retval = -2;
   } else if (retval == -2) {
     sprintf(serr, "no heliacal date found within %d synodic periods", MaxCountSynodicPeriod);
-    retval = ERR;
+    retval = SE_ERR;
   }
   if (serr_ret != NULL && *serr != '\0')
     strcpy(serr_ret, serr);
diff --git a/src/libswe/swehouse.c b/src/libswe/swehouse.c
index 46c2a9e..c923aea 100644
--- a/src/libswe/swehouse.c
+++ b/src/libswe/swehouse.c
@@ -136,7 +136,7 @@ int CALL_CONV swe_houses(double tjd_ut,
     int flags = SEFLG_SPEED| SEFLG_EQUATORIAL;
     double xp[6];
     int result = swe_calc_ut(tjd_ut, SE_SUN, flags, xp, NULL);
-    if (result < 0) return ERR;
+    if (result < 0) return SE_ERR;
     ascmc[9] = xp[1];	// declination in ascmc[9];
   }
 #ifdef TRACE
@@ -221,7 +221,7 @@ int CALL_CONV swe_houses_ex(double tjd_ut,
   if (toupper(hsys) ==  'I') {	// compute sun declination for sunshine houses
     int flags = SEFLG_SPEED| SEFLG_EQUATORIAL;
     int result = swe_calc_ut(tjd_ut, SE_SUN, flags, xp, NULL);
-    if (result < 0) return ERR;
+    if (result < 0) return SE_ERR;
     ascmc[9] = xp[1];	// declination in ascmc[9];
   }
   if (iflag & SEFLG_SIDEREAL) { 
@@ -938,7 +938,7 @@ static int CalcH(
     } else {
       retc = sunshine_solution_makransky(th, fi, ekl, hsp);
     }
-    if (retc == ERR) {	// only Makransky version does this
+    if (retc == SE_ERR) {	// only Makransky version does this
       strcpy(hsp->serr, "within polar circle, switched to Porphyry"); 
       hsy = 'O';
       goto porphyry;
@@ -946,7 +946,7 @@ static int CalcH(
     break;
   case 'K': /* Koch houses */
     if (fabs(fi) >= 90 - ekl) {  /* within polar circle */
-      retc = ERR;
+      retc = SE_ERR;
       strcpy(hsp->serr, "within polar circle, switched to Porphyry"); 
       goto porphyry;
     }
@@ -1276,7 +1276,7 @@ porphyry:
       hsp->cusp[i] = 0;
     }
     if (fabs(fi) >= 90 - ekl) {  /* within polar circle */
-      retc = ERR;
+      retc = SE_ERR;
       strcpy(hsp->serr, "within polar circle, switched to Porphyry"); 
       goto porphyry;
     }
@@ -1437,7 +1437,7 @@ porphyry:
     break;
   default:	/* Placidus houses */
     if (fabs(fi) >= 90 - ekl) {  /* within polar circle */
-      retc = ERR;
+      retc = SE_ERR;
       strcpy(hsp->serr, "within polar circle, switched to Porphyry"); 
       goto porphyry;
     } 
@@ -1812,7 +1812,7 @@ if (1) {
   		// which we do not know. If it sees ascmc[9] == 99, it uses
 		// the one is saved from last call. can lead to bugs, but can 
 		// also solve many problems.
-  if (swe_houses_armc(armc, geolat, eps, hsys, hcusp, ascmc) == ERR) {
+  if (swe_houses_armc(armc, geolat, eps, hsys, hcusp, ascmc) == SE_ERR) {
     if (serr != NULL)
       sprintf(serr, "swe_house_pos(): failed for system %c", hsys);
   } else {
@@ -2385,7 +2385,7 @@ if (1) {
     break;
   default:
     hpos = 0;
-    if (swe_houses_armc(armc, geolat, eps, hsys, hcusp, ascmc) == ERR) {
+    if (swe_houses_armc(armc, geolat, eps, hsys, hcusp, ascmc) == SE_ERR) {
       if (serr != NULL)
 	sprintf(serr, "swe_house_pos(): failed for system %c", hsys);
       break;
@@ -2450,7 +2450,7 @@ int sunshine_init(double lat, double dec, double xh[])
   xh[11] = 1 * dsa / 3;
   xh[12] = 2 * dsa / 3;
   if (fabs(arg) >= 1)
-    return ERR;
+    return SE_ERR;
   return OK;
 }
 
@@ -2470,10 +2470,10 @@ static int sunshine_solution_makransky(double ramc, double lat, double ecl, stru
   int ih;
   // if (90 - fabs(lat) <= ecl) {
   //   strcpy(hsp->serr, "Sunshine in polar circle not allowed");
-  //   return ERR;
+  //   return SE_ERR;
   // }
-  if (sunshine_init(lat, dec, xh) == ERR)
-    return ERR;
+  if (sunshine_init(lat, dec, xh) == SE_ERR)
+    return SE_ERR;
   for (ih = 1; ih <= 12; ih++) {
     double z = 0;
     if ((ih - 1) % 3 == 0) continue;	// skip 1,4,7,10
@@ -2606,7 +2606,7 @@ static int sunshine_solution_treindl(double ramc, double lat, double ecl, struct
   double dec = hsp->sundec;
   // if (90 - fabs(lat) <= ecl) {
   //   strcpy(hsp->serr, "Sunshine in polar circle not allowed");
-  //   return ERR;
+  //   return SE_ERR;
   // }
   sinlat = sind(lat);
   coslat = cosd(lat);
@@ -2624,8 +2624,8 @@ static int sunshine_solution_treindl(double ramc, double lat, double ecl, struct
       xh[ih] = -xh[ih];
     }
   }
-  //if (sunshine_init(lat, dec, xh) == ERR)
-  //  return ERR;
+  //if (sunshine_init(lat, dec, xh) == SE_ERR)
+  //  return SE_ERR;
   // HP is the house point on the semidiurnal arc
   // CP = intersection house meridian with prime vertical
   // MP = intersection house meridian with equator
@@ -2661,7 +2661,7 @@ static int sunshine_solution_treindl(double ramc, double lat, double ecl, struct
     // now Sinussatz
     if (c < 1e-6) {
       sprintf(hsp->serr, "Sunshine house %d c=%le very small", ih, c);
-      retval = ERR;
+      retval = SE_ERR;
     }
     sinzd = sind(xhs) * sind(alpha2) / sind(c);
     zd = asind(sinzd);
diff --git a/src/libswe/swejpl.c b/src/libswe/swejpl.c
index 501e979..28a45a5 100644
--- a/src/libswe/swejpl.c
+++ b/src/libswe/swejpl.c
@@ -301,7 +301,7 @@ static int32 fsizer(char *serr)
     default:
       if (serr != NULL)
 	sprintf(serr,"unknown numde value %d;", numde);
-      return ERR;
+      return SE_ERR;
   }
 #endif
   if (ksize < 1000 || ksize > 5000) {
@@ -905,7 +905,7 @@ int swi_open_jpl_file(double *ss, char *fname, char *fpath, char *serr)
     ) {
     if (serr != NULL)
       strcpy(serr, "error in malloc() with JPL ephemeris.");
-    return ERR;
+    return SE_ERR;
   }
   strcpy(js->jplfname, fname);
   strcpy(js->jplfpath, fpath);
diff --git a/src/libswe/swemmoon.c b/src/libswe/swemmoon.c
index 16595e6..047a077 100644
--- a/src/libswe/swemmoon.c
+++ b/src/libswe/swemmoon.c
@@ -886,7 +886,7 @@ int swi_moshmoon(double tjd, AS_BOOL do_save, double *xpmret, char *serr)
       if (strlen(serr) + strlen(s) < AS_MAXCH)
 	strcat(serr, s);
     }
-    return(ERR);
+    return(SE_ERR);
   }  
   /* if moon has already been computed */
   if (tjd == pdp->teval && pdp->iephe == SEFLG_MOSEPH) {
@@ -1510,7 +1510,7 @@ int swi_mean_node(double J, double *pol, char *serr)
       if (strlen(serr) + strlen(s) < AS_MAXCH)
 	strcat(serr, s);
     }
-    return ERR;
+    return SE_ERR;
   }
   mean_elements();
   dcor = corr_mean_node(J) * 3600;
@@ -1583,7 +1583,7 @@ int swi_mean_apog(double J, double *pol, char *serr)
       if (strlen(serr) + strlen(s) < AS_MAXCH)
 	strcat(serr, s);
     }
-    return(ERR);
+    return(SE_ERR);
   }
   mean_elements();
   pol[0] = swi_mod2PI((SWELP - MP) * STR + PI);
diff --git a/src/libswe/swemplan.c b/src/libswe/swemplan.c
index 51794b6..fbccb8b 100644
--- a/src/libswe/swemplan.c
+++ b/src/libswe/swemplan.c
@@ -304,7 +304,7 @@ int swi_moshplan(double tjd, int ipli, AS_BOOL do_save, double *xpret, double *x
       if (strlen(serr) + strlen(s) < AS_MAXCH)
 	strcat(serr, s);
     }
-    return(ERR);
+    return(SE_ERR);
   }  
   /* earth, for geocentric position */
   if (do_earth) {
@@ -515,7 +515,7 @@ char *swi_get_fict_name(int32 ipl, char *snam)
 {
   if (read_elements_file(ipl, 0, NULL, NULL, 
        NULL, NULL, NULL, NULL, NULL, NULL, 
-       snam, NULL, NULL) == ERR)
+       snam, NULL, NULL) == SE_ERR)
     strcpy(snam, "name not found");
   return snam;
 }
@@ -594,8 +594,8 @@ int swi_osc_el_plan(double tjd, double *xp, int ipl, int ipli, double *xearth, d
    */
   if (read_elements_file(ipl, tjd, &tjd0, &tequ, 
        &mano, &sema, &ecce, &parg, &node, &incl, 
-       NULL, &fict_ifl, serr) == ERR)
-    return ERR;
+       NULL, &fict_ifl, serr) == SE_ERR)
+    return SE_ERR;
   dmot = 0.9856076686 * DEGTORAD / sema / sqrt(sema);	/* daily motion */
   if (fict_ifl & FICT_GEO)
     dmot /= sqrt(SUN_EARTH_MRAT);
@@ -710,7 +710,7 @@ static int read_elements_file(int32 ipl, double tjd,
     if (ipl >= SE_NFICT_ELEM) {
       if (serr != NULL)
         sprintf(serr, "error no elements for fictitious body no %7.0f", (double) ipl);
-      return ERR;
+      return SE_ERR;
     }
     if (tjd0 != NULL)
       *tjd0 = plan_oscu_elem[ipl][0];			/* epoch */
@@ -812,7 +812,7 @@ static int read_elements_file(int32 ipl, double tjd,
     if (mano != NULL) {
       retc = check_t_terms(tt, cpos[2], mano);
 	  *mano = swe_degnorm(*mano);
-      if (retc == ERR) {
+      if (retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s mean anomaly value invalid", serri);
 	}
@@ -830,7 +830,7 @@ static int read_elements_file(int32 ipl, double tjd,
     /* semi-axis */
     if (sema != NULL) {
       retc = check_t_terms(tt, cpos[3], sema);
-      if (*sema <= 0 || retc == ERR) {
+      if (*sema <= 0 || retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s semi-axis value invalid", serri);
 	}
@@ -840,7 +840,7 @@ static int read_elements_file(int32 ipl, double tjd,
     /* eccentricity */
     if (ecce != NULL) {
       retc = check_t_terms(tt, cpos[4], ecce);
-      if (*ecce >= 1 || *ecce < 0 || retc == ERR) {
+      if (*ecce >= 1 || *ecce < 0 || retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s eccentricity invalid (no parabolic or hyperbolic orbits allowed)", serri);
 	}
@@ -851,7 +851,7 @@ static int read_elements_file(int32 ipl, double tjd,
     if (parg != NULL) {
       retc = check_t_terms(tt, cpos[5], parg);
 	  *parg = swe_degnorm(*parg);
-      if (retc == ERR) {
+      if (retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s perihelion argument value invalid", serri);
 	}
@@ -863,7 +863,7 @@ static int read_elements_file(int32 ipl, double tjd,
     if (node != NULL) {
       retc = check_t_terms(tt, cpos[6], node);
 	  *node = swe_degnorm(*node);
-      if (retc == ERR) {
+      if (retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s node value invalid", serri);
 	}
@@ -875,7 +875,7 @@ static int read_elements_file(int32 ipl, double tjd,
     if (incl != NULL) {
       retc = check_t_terms(tt, cpos[7], incl);
 	  *incl = swe_degnorm(*incl);
-      if (retc == ERR) {
+      if (retc == SE_ERR) {
         if (serr != NULL) {
           sprintf(serr, "%s inclination value invalid", serri);
 	}
@@ -910,7 +910,7 @@ static int read_elements_file(int32 ipl, double tjd,
   return OK;
 return_err:
   fclose(fp);
-  return ERR;
+  return SE_ERR;
 }
 #endif
 
diff --git a/src/libswe/sweodef.h b/src/libswe/sweodef.h
index 330abbf..03994b1 100644
--- a/src/libswe/sweodef.h
+++ b/src/libswe/sweodef.h
@@ -237,7 +237,7 @@
 
 #ifndef OK 
 #  define OK (0)
-#  define ERR (-1)
+#  define SE_ERR (-1)
 #endif
 
 /* hack because UCHAR is already used by mingw gcc */
diff --git a/src/libswe/swepcalc.c b/src/libswe/swepcalc.c
index 4c45f9f..2ff7a3f 100644
--- a/src/libswe/swepcalc.c
+++ b/src/libswe/swepcalc.c
@@ -96,7 +96,7 @@ as needed for complete nathan data records.
 The function knows itself how many planets and in which mode
 they have to be calculated for Nathan. 
 
-return OK or ERR
+return OK or SE_ERR
 
 The returned positions are in centiseconds, our standard
 coordinate format for fast mathematics with planetary positions.
@@ -122,13 +122,13 @@ int nacalc (double	jd_ad,	/* universal time relative  julian date */
     } else {
       plon [planet] = -1;
       if (pspe != NULL) pspe [planet] = 0;
-      if (result != ERR) {	/* save first error message */
+      if (result != SE_ERR) {	/* save first error message */
 	strcpy(err, placalc_get_errtext());
       }
-      result = ERR;
+      result = SE_ERR;
     }
   }
-  if (result == ERR)
+  if (result == SE_ERR)
     strcpy(perrtx, err);
   return result;
 }	/* end nacalc */
@@ -143,9 +143,9 @@ int nacalc (double	jd_ad,	/* universal time relative  julian date */
 
    Explanation of the arguments: see the functions header.
 
-   Returns OK or ERR (if some planet out of time range). OK and ERR are
+   Returns OK or SE_ERR (if some planet out of time range). OK and SE_ERR are
    defined in ourdef.h and must not be confused with TRUE and FALSE.
-   OK and ERR are of type int, not of type AS_BOOL.
+   OK and SE_ERR are of type int, not of type AS_BOOL.
 
    Bits used in flag:
    CALC_BIT_HELIO  		0 = geocentric, 1 = heliocentric
@@ -199,7 +199,7 @@ int calc(int  planet,  	/* planet index as defined in placalc.h,
     ipl = plac2swe[planet];
   else {
     sprintf(perrtx, "invalid planet number %d. ", planet);
-    return ERR;
+    return SE_ERR;
   }
   /* flag */
   if (flag & CALC_BIT_HELIO)
@@ -212,7 +212,7 @@ int calc(int  planet,  	/* planet index as defined in placalc.h,
   if (flag & CALC_BIT_SPEED)
     iflag |= SEFLG_SPEED;
   /* ecliptic and nutation */
-  if ((iflagret = swe_calc(tjd, ipl, iflag, x, perrtx)) == ERR)
+  if ((iflagret = swe_calc(tjd, ipl, iflag, x, perrtx)) == SE_ERR)
     return iflagret;
   if (ipl == SE_ECL_NUT) {
     *alng = nut = x[2];
diff --git a/src/libswe/swepdate.c b/src/libswe/swepdate.c
index 4e0d2d6..eb418fd 100644
--- a/src/libswe/swepdate.c
+++ b/src/libswe/swepdate.c
@@ -178,7 +178,7 @@ void revjul (double jd, int gregflag,
   into the Julian day number tgmt, which is an Astrodienst relative
   Julian date.
   The function checks that the input is a legal combination
-  of dates; for illegal dates like 32 January 1993 it returns ERR
+  of dates; for illegal dates like 32 January 1993 it returns SE_ERR
   but still converts the date correctly, i.e. like 1 Feb 1993.
   The function is usually used to convert user input of birth data
   into the Julian day number. Illegal dates should be notified to the user.
@@ -192,7 +192,7 @@ void revjul (double jd, int gregflag,
   etc.
   Many users of Astro programs do not know about this difference.
 
-  Return: OK or ERR (for illegal date)
+  Return: OK or SE_ERR (for illegal date)
 *********************************************************/
 
 int date_conversion (int d ,
@@ -217,6 +217,6 @@ int date_conversion (int d ,
   if (rmon == m && rday == d && ryear == y) {
     return OK;
   } else {
-    return ERR;
+    return SE_ERR;
   }
 }	/* end date_conversion */
diff --git a/src/libswe/sweph.c b/src/libswe/sweph.c
index 152dcfb..b00e9d3 100644
--- a/src/libswe/sweph.c
+++ b/src/libswe/sweph.c
@@ -428,7 +428,7 @@ int32 CALL_CONV swe_calc(double tjd, int ipl, int32 iflag,
      */
     sd->tsave = tjd;
     sd->ipl = ipl;
-    if ((sd->iflgsave = swecalc(tjd, ipl, iflag, sd->xsaves, serr)) == ERR) 
+    if ((sd->iflgsave = swecalc(tjd, ipl, iflag, sd->xsaves, serr)) == SE_ERR) 
       goto return_error;
   } else {
     /* 
@@ -455,11 +455,11 @@ int32 CALL_CONV swe_calc(double tjd, int ipl, int32 iflag,
 	dt = PLAN_SPEED_INTV;
 	break;
     } 
-    if ((sd->iflgsave = swecalc(tjd-dt, ipl, iflag, x0, serr)) == ERR)
+    if ((sd->iflgsave = swecalc(tjd-dt, ipl, iflag, x0, serr)) == SE_ERR)
       goto return_error; 
-    if ((sd->iflgsave = swecalc(tjd+dt, ipl, iflag, x2, serr)) == ERR)
+    if ((sd->iflgsave = swecalc(tjd+dt, ipl, iflag, x2, serr)) == SE_ERR)
       goto return_error; 
-    if ((sd->iflgsave = swecalc(tjd, ipl, iflag, sd->xsaves, serr)) == ERR)
+    if ((sd->iflgsave = swecalc(tjd, ipl, iflag, sd->xsaves, serr)) == SE_ERR)
       goto return_error; 
     denormalize_positions(x0, sd->xsaves, x2);
     calc_speed(x0, sd->xsaves, x2, dt);
@@ -519,7 +519,7 @@ return_error:
 #ifdef TRACE
   trace_swe_calc(2, tjd, ipl, iflag, xx, serr);
 #endif
-  return ERR; 
+  return SE_ERR; 
 }
 
 int32 CALL_CONV swe_calc_ut(double tjd_ut, int32 ipl, int32 iflag, 
@@ -598,7 +598,7 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
   if ((iflag & SEFLG_BARYCTR) && (iflag & SEFLG_MOSEPH)) {
     if (serr != NULL)
       strcpy(serr, "barycentric Moshier positions are not supported.");
-    return ERR;
+    return SE_ERR;
   }
   if (epheflag != SEFLG_MOSEPH && !swed.ephe_path_is_set && !swed.jpl_file_is_open)
     swe_set_ephe_path(NULL);
@@ -638,7 +638,7 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
       case SEFLG_JPLEPH:
 	retc = jplplan(tjd, ipli, iflag, DO_SAVE, NULL, NULL, NULL, serr);
 	/* read error or corrupt file */
-	if (retc == ERR) 
+	if (retc == SE_ERR) 
 	  goto return_error;
         /* jpl ephemeris not on disk or date beyond ephemeris range 
 	 *     or file corrupt */
@@ -671,7 +671,7 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
 	retc = sweplan(tjd, ipli, SEI_FILE_MOON, iflag, DO_SAVE,
 			NULL, NULL, NULL, NULL, serr);
 #endif
-	if (retc == ERR)
+	if (retc == SE_ERR)
 	  goto return_error;
 	/* if sweph file not found, switch to moshier */
         if (retc == NOT_AVAILABLE) {
@@ -687,11 +687,11 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
       case SEFLG_MOSEPH:
 	moshier_moon:
         retc = swi_moshmoon(tjd, DO_SAVE, NULL, serr);/**/
-	if (retc == ERR)
+	if (retc == SE_ERR)
 	  goto return_error;
 	/* for hel. position, we need earth as well */
 	retc = swi_moshplan(tjd, SEI_EARTH, DO_SAVE, NULL, NULL, serr);/**/
-	if (retc == ERR)
+	if (retc == SE_ERR)
 	  goto return_error;
 	break;
       default:
@@ -729,7 +729,7 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
 	    goto sweph_sbar;
 	}
 	retc = swi_pleph(tjd, J_SUN, J_SBARY, psdp->x, serr);
-	if (retc == ERR || retc == BEYOND_EPH_LIMITS) {
+	if (retc == SE_ERR || retc == BEYOND_EPH_LIMITS) {
 	  swi_close_jpl_file();
 	  swed.jpl_file_is_open = FALSE;
 	  goto return_error;
@@ -750,11 +750,11 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
 	 * it is saved in swed.pldat[SEI_SUNBARY].x */
 	retc = sweplan(tjd, SEI_EARTH, SEI_FILE_PLANET, iflag, DO_SAVE, NULL, NULL, NULL, NULL, serr);
 #if 1
-	if (retc == ERR || retc == NOT_AVAILABLE)
+	if (retc == SE_ERR || retc == NOT_AVAILABLE)
 	  goto return_error;
 #else	/* this code would be needed if barycentric moshier calculation
 	 * were implemented */
-	if (retc == ERR)
+	if (retc == SE_ERR)
 	  goto return_error;
 	/* if sweph file not found, switch to moshier */
         if (retc == NOT_AVAILABLE) {
@@ -774,7 +774,7 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
 #if 0
 	moshier_sbar:
 #endif
-	return ERR;
+	return SE_ERR;
 	break;
     }
     /* flags */
@@ -825,7 +825,7 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
     pdp = &swed.pldat[ipli];
     xp = pdp->xreturn;
     retc = main_planet(tjd, ipli, epheflag, iflag, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     /* iflag has possibly changed in main_planet() */
     iflag = pdp->xflgs;
@@ -844,11 +844,11 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
     xp = ndp->xreturn;
     xp2 = ndp->x;
     retc = swi_mean_node(tjd, xp2, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     /* speed (is almost constant; variation < 0.001 arcsec) */
     retc = swi_mean_node(tjd - MEAN_NODE_SPEED_INTV, xp2+3, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     xp2[3] = swe_difrad2n(xp2[0], xp2[3]) / MEAN_NODE_SPEED_INTV;
     xp2[4] = xp2[5] = 0;
@@ -866,7 +866,7 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
       ndp->xreturn[8] = 0.0;	/* z coordinate        */
       ndp->xreturn[11] = 0.0;	/*               speed */
     }
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /********************************************** 
    * mean lunar apogee ('dark moon', 'lilith')  *
@@ -883,11 +883,11 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
     xp = ndp->xreturn;
     xp2 = ndp->x;
     retc = swi_mean_apog(tjd, xp2, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     /* speed (is not constant! variation ~= several arcsec) */
     retc = swi_mean_apog(tjd - MEAN_NODE_SPEED_INTV, xp2+3, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     for(i = 0; i <= 1; i++)
       xp2[3+i] = swe_difrad2n(xp2[i], xp2[3+i]) / MEAN_NODE_SPEED_INTV;
@@ -900,7 +900,7 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
     /* to avoid infinitesimal deviations from r-speed = 0 
      * that result from conversions */
     ndp->xreturn[5] = 0.0;	/*               speed */
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /*********************************************** 
    * osculating lunar node ('true node')         *    
@@ -924,7 +924,7 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
       ndp->xreturn[8] = 0.0;	/* z coordinate        */
       ndp->xreturn[11] = 0.0;	/*               speed */
     }
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /*********************************************** 
    * osculating lunar apogee                     *    
@@ -940,7 +940,7 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
     xp = ndp->xreturn;
     retc = lunar_osc_elem(tjd, SEI_OSCU_APOG, iflag, serr); 
     iflag = ndp->xflgs;
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /*********************************************** 
    * interpolated lunar apogee                   *    
@@ -958,13 +958,13 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
       if (serr != NULL)
 	sprintf(serr, "Interpolated apsides are restricted to JD %8.1f - JD %8.1f",
 		MOSHLUEPH_START, MOSHLUEPH_END);
-      return ERR;
+      return SE_ERR;
     }
     ndp = &swed.nddat[SEI_INTP_APOG];
     xp = ndp->xreturn;
     retc = intp_apsides(tjd, SEI_INTP_APOG, iflag, serr); 
     iflag = ndp->xflgs;
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /*********************************************** 
    * interpolated lunar perigee                  *    
@@ -982,13 +982,13 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
       if (serr != NULL)
 	sprintf(serr, "Interpolated apsides are restricted to JD %8.1f - JD %8.1f",
 		MOSHLUEPH_START, MOSHLUEPH_END);
-      return ERR;
+      return SE_ERR;
     }
     ndp = &swed.nddat[SEI_INTP_PERG];
     xp = ndp->xreturn;
     retc = intp_apsides(tjd, SEI_INTP_PERG, iflag, serr); 
     iflag = ndp->xflgs;
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
   /*********************************************** 
    * minor planets                               *    
@@ -1031,19 +1031,19 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
       if (serr != NULL)
 	sprintf(serr, "Chiron's ephemeris is restricted to JD %8.1f - JD %8.1f",
 		CHIRON_START, CHIRON_END);
-      return ERR;
+      return SE_ERR;
     }
     if (ipli == SEI_PHOLUS && (tjd < PHOLUS_START || tjd > PHOLUS_END)) {
       if (serr != NULL)
 	sprintf(serr, 
 		"Pholus's ephemeris is restricted to JD %8.1f - JD %8.1f",
 		PHOLUS_START, PHOLUS_END);
-      return ERR;
+      return SE_ERR;
     }
   do_asteroid:
     /* earth and sun are also needed */
     retc = main_planet(tjd, SEI_EARTH, epheflag, iflag, serr);
-    if (retc == ERR) 
+    if (retc == SE_ERR) 
       goto return_error;
     /* iflag (ephemeris bit) has possibly changed in main_planet() */
     iflag = swed.pldat[SEI_EARTH].xflgs;
@@ -1054,10 +1054,10 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
     }
     /* asteroid */
     retc = sweph(tjd, ipli_ast, ifno, iflag, psdp->x, DO_SAVE, NULL, serr);
-    if (retc == ERR || retc == NOT_AVAILABLE) 
+    if (retc == SE_ERR || retc == NOT_AVAILABLE) 
       goto return_error;
     retc = app_pos_etc_plan(ipli_ast, iflag, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     /* app_pos_etc_plan() might have failed, if t(light-time)
      * is beyond ephemeris range. in this case redo with Moshier 
@@ -1108,10 +1108,10 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
     /* planet from osculating elements */
     if (swi_osc_el_plan(tjd, pdp->x, ipl-SE_FICT_OFFSET, ipli, pedp->x, psdp->x, serr) != OK)
       goto return_error;
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     retc = app_pos_etc_plan_osc(ipl, ipli, iflag, serr);
-    if (retc == ERR)
+    if (retc == SE_ERR)
       goto return_error;
     /* app_pos_etc_plan_osc() might have failed, if t(light-time)
      * is beyond ephemeris range. in this case redo with Moshier 
@@ -1144,7 +1144,7 @@ static int32 swecalc(double tjd, int ipl, int32 iflag, double *x, char *serr)
   return_error:;
   for (i = 0; i < 24; i++)
     x[i] = 0;
-  return ERR;
+  return SE_ERR;
 }
 
 static void free_planets(void)
@@ -1382,15 +1382,15 @@ void load_dpsi_deps(void)
     return;
   fp = swi_fopen(-1, DPSI_DEPS_IAU1980_FILE_EOPC04, swed.ephepath, NULL);
   if (fp == NULL) {
-    swed.eop_dpsi_loaded = ERR;
+    swed.eop_dpsi_loaded = SE_ERR;
     return;
   }
   if ((swed.dpsi = (double *) calloc((size_t) SWE_DATA_DPSI_DEPS, sizeof(double))) == NULL) {
-    swed.eop_dpsi_loaded = ERR;
+    swed.eop_dpsi_loaded = SE_ERR;
     return;
   }
   if ((swed.deps = (double *) calloc((size_t) SWE_DATA_DPSI_DEPS, sizeof(double))) == NULL) {
-    swed.eop_dpsi_loaded = ERR;
+    swed.eop_dpsi_loaded = SE_ERR;
     return;
   }
   swed.eop_tjd_beg_horizons = DPSI_DEPS_IAU1980_TJD0_HORIZONS;
@@ -1554,8 +1554,8 @@ static int main_planet(double tjd, int ipli, int32 epheflag, int32 iflag,
     case SEFLG_JPLEPH:
       retc = jplplan(tjd, ipli, iflag, DO_SAVE, NULL, NULL, NULL, serr);
       /* read error or corrupt file */
-      if (retc == ERR) 
-	return ERR;
+      if (retc == SE_ERR) 
+	return SE_ERR;
       /* jpl ephemeris not on disk or date beyond ephemeris range */
       if (retc == NOT_AVAILABLE) {
 	iflag = (iflag & ~SEFLG_JPLEPH) | SEFLG_SWIEPH;
@@ -1569,7 +1569,7 @@ static int main_planet(double tjd, int ipli, int32 epheflag, int32 iflag,
 	    strcat(serr, " \nusing Moshier Eph; ");
 	  goto moshier_planet;
 	} else {
-	  return ERR;
+	  return SE_ERR;
 	}
       }
       /* geocentric, lighttime etc. */
@@ -1577,8 +1577,8 @@ static int main_planet(double tjd, int ipli, int32 epheflag, int32 iflag,
 	retc = app_pos_etc_sun(iflag, serr)/**/;
       else
 	retc = app_pos_etc_plan(ipli, iflag, serr);
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       /* t for light-time beyond ephemeris range */
       if (retc == NOT_AVAILABLE) {
 	iflag = (iflag & ~SEFLG_JPLEPH) | SEFLG_SWIEPH;
@@ -1592,15 +1592,15 @@ static int main_planet(double tjd, int ipli, int32 epheflag, int32 iflag,
 	    strcat(serr, " \nusing Moshier Eph; ");
 	  goto moshier_planet;
 	} else
-	  return ERR;
+	  return SE_ERR;
       }
       break;
     case SEFLG_SWIEPH:
       sweph_planet:
       /* compute barycentric planet (+ earth, sun, moon) */
       retc = sweplan(tjd, ipli, SEI_FILE_PLANET, iflag, DO_SAVE, NULL, NULL, NULL, NULL, serr);
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       /* if sweph file not found, switch to moshier */
       if (retc == NOT_AVAILABLE) {
 	if (tjd > MOSHPLEPH_START && tjd < MOSHPLEPH_END) {
@@ -1609,15 +1609,15 @@ static int main_planet(double tjd, int ipli, int32 epheflag, int32 iflag,
 	    strcat(serr, " \nusing Moshier eph.; ");
 	  goto moshier_planet;
 	} else 
-	  return ERR;
+	  return SE_ERR;
       }
       /* geocentric, lighttime etc. */
       if (ipli == SEI_SUN)
 	retc = app_pos_etc_sun(iflag, serr)/**/;
       else
 	retc = app_pos_etc_plan(ipli, iflag, serr);
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       /* if sweph file for t(lighttime) not found, switch to moshier */
       if (retc == NOT_AVAILABLE) {
 	if (tjd > MOSHPLEPH_START && tjd < MOSHPLEPH_END) {
@@ -1626,21 +1626,21 @@ static int main_planet(double tjd, int ipli, int32 epheflag, int32 iflag,
 	    strcat(serr, " \nusing Moshier eph.; ");
 	  goto moshier_planet;
 	} else
-	  return ERR;
+	  return SE_ERR;
       }
       break;
     case SEFLG_MOSEPH:
       moshier_planet:
       retc = swi_moshplan(tjd, ipli, DO_SAVE, NULL, NULL, serr);/**/
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       /* geocentric, lighttime etc. */
       if (ipli == SEI_SUN)
 	retc = app_pos_etc_sun(iflag, serr)/**/;
       else
 	retc = app_pos_etc_plan(ipli, iflag, serr);
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       break;
     default:
       break;
@@ -1679,7 +1679,7 @@ static int main_planet_bary(double tjd, int ipli, int32 epheflag, int32 iflag, A
     case SEFLG_JPLEPH:
       retc = jplplan(tjd, ipli, iflag, do_save, xp, xe, xs, serr);
       /* read error or corrupt file */
-      if (retc == ERR || retc == BEYOND_EPH_LIMITS) 
+      if (retc == SE_ERR || retc == BEYOND_EPH_LIMITS) 
 	return retc;
       /* jpl ephemeris not on disk or date beyond ephemeris range */
       if (retc == NOT_AVAILABLE) {
@@ -1694,11 +1694,11 @@ static int main_planet_bary(double tjd, int ipli, int32 epheflag, int32 iflag, A
       /* compute barycentric planet (+ earth, sun, moon) */
       retc = sweplan(tjd, ipli, SEI_FILE_PLANET, iflag, do_save, xp, xe, xs, xm, serr);
 #if 1
-      if (retc == ERR || retc == NOT_AVAILABLE)
+      if (retc == SE_ERR || retc == NOT_AVAILABLE)
 	return retc;
 #else /* if barycentric moshier calculation were implemented */
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       /* if sweph file not found, switch to moshier */
       if (retc == NOT_AVAILABLE) {
 	if (tjd > MOSHPLEPH_START && tjd < MOSHPLEPH_END) {
@@ -1716,8 +1716,8 @@ static int main_planet_bary(double tjd, int ipli, int32 epheflag, int32 iflag, A
       moshier_planet:
 #endif
       retc = swi_moshplan(tjd, ipli, do_save, xp, xe, serr);/**/
-      if (retc == ERR)
-	return ERR;
+      if (retc == SE_ERR)
+	return SE_ERR;
       for (i = 0; i <= 5; i++)
 	xs[i] = 0;
       break;
@@ -1873,7 +1873,7 @@ static int sweplan(double tjd, int ipli, int ifno, int32 iflag, AS_BOOL do_save,
 	xpm[i] = pmdp->x[i];
     } else {
       retc = sweph(tjd, SEI_MOON, SEI_FILE_MOON, iflag, NULL, do_save, xpm, serr);
-      if (retc == ERR) 
+      if (retc == SE_ERR) 
 	return(retc);
       /* if moon file doesn't exist, take moshier moon */
       if (swed.fidat[SEI_FILE_MOON].fptr == NULL) {
@@ -2467,7 +2467,7 @@ static int app_pos_etc_plan(int ipli, int32 iflag, char *serr)
     if (swed.topd.teval != pedp->teval
       || swed.topd.teval == 0) {
       if (swi_get_observer(pedp->teval, iflag | SEFLG_NONUT, DO_SAVE, xobs, serr) != OK)
-        return ERR;
+        return SE_ERR;
     } else {
       for (i = 0; i <= 5; i++)
         xobs[i] = swed.topd.xobs[i];
@@ -2629,7 +2629,7 @@ static int app_pos_etc_plan(int ipli, int32 iflag, char *serr)
       /* observer position for t(light-time) */
       if (iflag & SEFLG_TOPOCTR) {
         if (swi_get_observer(t, iflag | SEFLG_NONUT, NO_SAVE, xobs2, serr) != OK)
-          return ERR;
+          return SE_ERR;
         for (i = 0; i <= 5; i++)
           xobs2[i] += xearth[i];
       } else {
@@ -2756,11 +2756,11 @@ static int app_pos_rest(struct plan_data *pdp, int32 iflag,
     /* project onto ecliptic t0 */
     if (swed.sidd.sid_mode & SE_SIDBIT_ECL_T0) {
       if (swi_trop_ra2sid_lon(x2000, pdp->xreturn+6, pdp->xreturn+18, iflag) != OK)
-	return ERR;
+	return SE_ERR;
     /* project onto solar system equator */
     } else if (swed.sidd.sid_mode & SE_SIDBIT_SSY_PLANE) {
       if (swi_trop_ra2sid_lon_sosy(x2000, pdp->xreturn+6, iflag) != OK)
-	return ERR;
+	return SE_ERR;
     } else {
     /* traditional algorithm */
       swi_cartpol_sp(pdp->xreturn+6, pdp->xreturn); 
@@ -2769,8 +2769,8 @@ static int app_pos_rest(struct plan_data *pdp, int32 iflag,
        * Therefore current values are saved... */
       for (i = 0; i < 24; i++)
         xxsv[i] = pdp->xreturn[i];
-      if (swi_get_ayanamsa_with_speed(pdp->teval, iflag, daya, serr) == ERR)
-        return ERR;
+      if (swi_get_ayanamsa_with_speed(pdp->teval, iflag, daya, serr) == SE_ERR)
+        return SE_ERR;
       /* ... and restored */
       for (i = 0; i < 24; i++)
         pdp->xreturn[i] = xxsv[i];
@@ -2915,8 +2915,8 @@ int32 swi_get_ayanamsa_ex(double tjd_et, int32 iflag, double *daya, char *serr)
     swe_set_sid_mode(SE_SIDM_FAGAN_BRADLEY, 0, 0);
   if (sip->sid_mode == SE_SIDM_TRUE_CITRA) {
     strcpy(star, "Spica"); /* Citra */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR) {
-      return ERR; 
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR) {
+      return SE_ERR; 
     }
     /*fprintf(stderr, "serr=%s\n", serr);*/
     *daya = swe_degnorm(x[0] - 180);
@@ -2924,36 +2924,36 @@ int32 swi_get_ayanamsa_ex(double tjd_et, int32 iflag, double *daya, char *serr)
   }
   if (sip->sid_mode == SE_SIDM_TRUE_REVATI) {
     strcpy(star, ",zePsc"); /* Revati */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 359.8333333333);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sip->sid_mode == SE_SIDM_TRUE_PUSHYA) {
     strcpy(star, ",deCnc"); /* Pushya = Asellus Australis */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 106);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sip->sid_mode == SE_SIDM_TRUE_SHEORAN) {
     strcpy(star, ",deCnc"); /* Asellus Australis */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 103.49264221625);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sip->sid_mode == SE_SIDM_TRUE_MULA) {
     strcpy(star, ",laSco"); /* Mula = lambda Scorpionis */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 240);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sip->sid_mode ==  SE_SIDM_GALCENT_0SAG) {
     strcpy(star, ",SgrA*"); /* Galactic Centre */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 240.0);
     return (retflag & SEFLG_EPHMASK);
     /*return swe_degnorm(x[0] - 359.83333333334);*/
@@ -2961,8 +2961,8 @@ int32 swi_get_ayanamsa_ex(double tjd_et, int32 iflag, double *daya, char *serr)
 #if 0
   if (sip->sid_mode ==  SE_SIDM_GALCENT_COCHRANE) {
     strcpy(star, ",SgrA*"); /* Galactic Centre */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 270.0);
     return (retflag & SEFLG_EPHMASK);
     /*return swe_degnorm(x[0] - 359.83333333334);*/
@@ -2970,8 +2970,8 @@ int32 swi_get_ayanamsa_ex(double tjd_et, int32 iflag, double *daya, char *serr)
 #endif
   if (sip->sid_mode ==  SE_SIDM_GALCENT_RGILBRAND) {
     strcpy(star, ",SgrA*"); /* Galactic Centre */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 210.0 - 90.0 * 0.3819660113);
     return (retflag & SEFLG_EPHMASK);
     /*return swe_degnorm(x[0] - 359.83333333334);*/
@@ -2980,8 +2980,8 @@ int32 swi_get_ayanamsa_ex(double tjd_et, int32 iflag, double *daya, char *serr)
     strcpy(star, ",SgrA*"); /* Galactic Centre */
     /* right ascension in polar projection onto the ecliptic, 
      * and that point is put in the middle of Mula */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_true | SEFLG_EQUATORIAL, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_true | SEFLG_EQUATORIAL, x, serr)) == SE_ERR)
+      return SE_ERR;
     eps = swi_epsiln(tjd_et, iflag) * RADTODEG;
     *daya = swi_armc_to_mc(x[0], eps);
     *daya = swe_degnorm(*daya - 246.6666666667);
@@ -2990,22 +2990,22 @@ int32 swi_get_ayanamsa_ex(double tjd_et, int32 iflag, double *daya, char *serr)
   }
   if (sip->sid_mode == SE_SIDM_GALEQU_IAU1958) {
     strcpy(star, ",GP1958"); /* Galactic Pole IAU 1958 */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 150);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sip->sid_mode == SE_SIDM_GALEQU_TRUE) {
     strcpy(star, ",GPol"); /* Galactic Pole modern, true */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 150);
     return (retflag & SEFLG_EPHMASK);
   }
   if (sip->sid_mode == SE_SIDM_GALEQU_MULA) {
     strcpy(star, ",GPol"); /* Galactic Pole modern, true */
-    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == ERR)
-      return ERR;
+    if ((retflag = swe_fixstar(star, tjd_et, iflag_galequ, x, serr)) == SE_ERR)
+      return SE_ERR;
     *daya = swe_degnorm(x[0] - 150 - 6.6666666667);
     return (retflag & SEFLG_EPHMASK);
   }
@@ -3039,11 +3039,11 @@ int32 swi_get_ayanamsa_with_speed(double tjd_et, int32 iflag, double *daya, char
   int32 retflag;
   t2 = tjd_et - tintv;
   retflag = swi_get_ayanamsa_ex(t2, iflag, &daya_t2, serr);
-  if (retflag == ERR) 
-    return ERR;
+  if (retflag == SE_ERR) 
+    return SE_ERR;
   retflag = swi_get_ayanamsa_ex(tjd_et, iflag, daya, serr);
-  if (retflag == ERR) 
-    return ERR;
+  if (retflag == SE_ERR) 
+    return SE_ERR;
   daya[1] = (daya[0] - daya_t2) / tintv;
   return retflag;
 }
@@ -3218,7 +3218,7 @@ static int app_pos_etc_plan_osc(int ipl, int ipli, int32 iflag, char *serr)
     if (swed.topd.teval != pedp->teval
       || swed.topd.teval == 0) {
       if (swi_get_observer(pedp->teval, iflag | SEFLG_NONUT, DO_SAVE, xobs, serr) != OK)
-        return ERR;
+        return SE_ERR;
     } else {
       for (i = 0; i <= 5; i++)
         xobs[i] = swed.topd.xobs[i];
@@ -3298,12 +3298,12 @@ static int app_pos_etc_plan_osc(int ipl, int ipli, int32 iflag, char *serr)
       /* for accuracy in speed, we will need earth as well */
       retc = main_planet_bary(t, SEI_EARTH, epheflag, iflag, NO_SAVE, xearth, xearth, xsun, xmoon, serr);
       if (swi_osc_el_plan(t, xx, ipl-SE_FICT_OFFSET, ipli, xearth, xsun, serr) != OK)
-	return ERR;
+	return SE_ERR;
       if (retc != OK)
 	return(retc);
       if (iflag & SEFLG_TOPOCTR) {
         if (swi_get_observer(t, iflag | SEFLG_NONUT, NO_SAVE, xobs2, serr) != OK)
-          return ERR;
+          return SE_ERR;
         for (i = 0; i <= 5; i++)
           xobs2[i] += xearth[i];
       } else {
@@ -3736,7 +3736,7 @@ static int app_pos_etc_sun(int32 iflag, char *serr)
     if (swed.topd.teval != pedp->teval
       || swed.topd.teval == 0) {
       if (swi_get_observer(pedp->teval, iflag | SEFLG_NONUT, DO_SAVE, xobs, serr) != OK)
-        return ERR;
+        return SE_ERR;
     } else {
       for (i = 0; i <= 5; i++)
         xobs[i] = swed.topd.xobs[i];
@@ -3825,7 +3825,7 @@ static int app_pos_etc_sun(int32 iflag, char *serr)
 	    /* with moshier there is no barycentric sun */
 	    break;
           default:
-	    retc = ERR;
+	    retc = SE_ERR;
 	    break;
 	} 
 	if (retc != OK)
@@ -3930,7 +3930,7 @@ static int app_pos_etc_moon(int32 iflag, char *serr)
     if (swed.topd.teval != pdp->teval
       || swed.topd.teval == 0) {
       if (swi_get_observer(pdp->teval, iflag | SEFLG_NONUT, DO_SAVE, xobs, serr) != OK)
-        return ERR;
+        return SE_ERR;
     } else {
       for (i = 0; i <= 5; i++)
         xobs[i] = swed.topd.xobs[i];
@@ -3993,7 +3993,7 @@ static int app_pos_etc_moon(int32 iflag, char *serr)
     } 
     if (iflag & SEFLG_TOPOCTR) {
       if (swi_get_observer(t, iflag | SEFLG_NONUT, NO_SAVE, xobs2, NULL) != OK)
-	  return ERR;
+	  return SE_ERR;
       for (i = 0; i <= 5; i++)
 	xobs2[i] += xe[i];
     } else if (iflag & SEFLG_BARYCTR) {
@@ -4256,7 +4256,7 @@ static int get_new_segment(double tjd, int ipli, int ifno, char *serr)
       }
       free(pdp->segp);
       pdp->segp = NULL;
-      return (ERR);
+      return (SE_ERR);
     }
     /* now unpack */
     for (i = 0; i < nsizes; i++) {
@@ -4328,7 +4328,7 @@ return_error_gns:
   free(fdp->fptr);
   fdp->fptr = NULL;
   free_planets();
-  return ERR;
+  return SE_ERR;
 }
 
 /* SWISSEPH
@@ -4687,7 +4687,7 @@ return_error:
   free(fdp->fptr);
   fdp->fptr = NULL;
   free_planets();
-  return(ERR);
+  return(SE_ERR);
 }
 
 /* SWISSEPH
@@ -4722,7 +4722,7 @@ static int do_fread(void *trg, int size, int count, int corrsize, FILE *fp, int3
 	  sprintf(serr, "Ephemeris file %s is damaged (2).", swed.fidat[ifno].fnam);
 	}
       }
-      return(ERR);
+      return(SE_ERR);
     } else
       return(OK);
   } else {
@@ -4733,7 +4733,7 @@ static int do_fread(void *trg, int size, int count, int corrsize, FILE *fp, int3
 	  sprintf(serr, "Ephemeris file %s is damaged (4).", swed.fidat[ifno].fnam);
 	}
       }
-      return(ERR);
+      return(SE_ERR);
     }
     if (size != corrsize) {
       memset((void *) targ, 0, (size_t) count * corrsize);
@@ -4969,7 +4969,7 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
   int i, j, istart;
   int ipli = SEI_MOON;
   int32 epheflag = SEFLG_DEFAULTEPH; 
-  int retc = ERR; 
+  int retc = SE_ERR; 
   int32 flg1, flg2;
   double daya[2];
 #if 0
@@ -5061,8 +5061,8 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
 	xp = xpos[i];
 	retc = jplplan(t, ipli, iflag, NO_SAVE, xp, NULL, NULL, serr);
 	/* read error or corrupt file */
-	if (retc == ERR)
-	  return(ERR);
+	if (retc == SE_ERR)
+	  return(SE_ERR);
 	/* light-time-corrected moon for apparent node 
 	 * this makes a difference of several milliarcseconds with
 	 * the node and 0.1" with the apogee.
@@ -5073,8 +5073,8 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
 	  dt = sqrt(square_sum(xpos[i])) * AUNIT / CLIGHT / 86400.0;     
 	  retc = jplplan(t-dt, ipli, iflag, NO_SAVE, xpos[i], NULL, NULL, serr);/**/
 	  /* read error or corrupt file */
-	  if (retc == ERR)
-	    return(ERR);
+	  if (retc == SE_ERR)
+	    return(SE_ERR);
         }
 	/* jpl ephemeris not on disk, or date beyond ephemeris range */
 	if (retc == NOT_AVAILABLE) {
@@ -5091,7 +5091,7 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
 	      strcat(serr, " \nusing Moshier Eph; ");
 	    break;
 	  } else
-	    return ERR;
+	    return SE_ERR;
 	}
 	/* precession and nutation etc. */
 	retc = swi_plan_for_osc_elem(iflag|SEFLG_SPEED, t, xpos[i]); /* retc is always ok */
@@ -5110,14 +5110,14 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
         else 
 	  t = tjd;
 	retc = swemoon(t, iflag | SEFLG_SPEED, NO_SAVE, xpos[i], serr);/**/
-	if (retc == ERR)
-	  return(ERR);
+	if (retc == SE_ERR)
+	  return(SE_ERR);
 	/* light-time-corrected moon for apparent node (~ 0.006") */
 	if ((iflag & SEFLG_TRUEPOS) == 0 && retc >= OK) { 
 	  dt = sqrt(square_sum(xpos[i])) * AUNIT / CLIGHT / 86400.0;     
 	  retc = swemoon(t-dt, iflag | SEFLG_SPEED, NO_SAVE, xpos[i], serr);/**/
-	  if (retc == ERR)
-	    return(ERR);
+	  if (retc == SE_ERR)
+	    return(SE_ERR);
         }
 	if (retc == NOT_AVAILABLE) {
 	  if (tjd > MOSHPLEPH_START && tjd < MOSHPLEPH_END) {
@@ -5127,7 +5127,7 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
 	      strcat(serr, " \nusing Moshier eph.; ");
 	    break;
 	  } else
-	    return ERR;
+	    return SE_ERR;
 	}
 	/* precession and nutation etc. */
 	retc = swi_plan_for_osc_elem(iflag|SEFLG_SPEED, t, xpos[i]); /* retc is always ok */
@@ -5148,7 +5148,7 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
         else 
 	  t = tjd;
 	retc = swi_moshmoon(t, NO_SAVE, xpos[i], serr);/**/
-	if (retc == ERR)
+	if (retc == SE_ERR)
 	  return(retc);
 #if 0
 	/* light-time-corrected moon for apparent node.
@@ -5358,8 +5358,8 @@ static int lunar_osc_elem(double tjd, int ipl, int32 iflag, char *serr)
        * sidereal code together */
       } else {
 	swi_cartpol_sp(ndp->xreturn+6, ndp->xreturn); 
-	if (swi_get_ayanamsa_with_speed(ndp->teval, iflag, daya, serr) == ERR)
-	  return ERR;
+	if (swi_get_ayanamsa_with_speed(ndp->teval, iflag, daya, serr) == SE_ERR)
+	  return SE_ERR;
 	ndp->xreturn[0] -= daya[0] * DEGTORAD;
 	ndp->xreturn[3] -= daya[1] * DEGTORAD;
 	swi_polcart_sp(ndp->xreturn, ndp->xreturn+6); 
@@ -5491,8 +5491,8 @@ static int intp_apsides(double tjd, int ipl, int32 iflag, char *serr)
     } else {
     /* traditional algorithm */
       swi_cartpol_sp(ndp->xreturn+6, ndp->xreturn); 
-      if (swi_get_ayanamsa_with_speed(ndp->teval, iflag, daya, serr) == ERR)
-        return ERR;
+      if (swi_get_ayanamsa_with_speed(ndp->teval, iflag, daya, serr) == SE_ERR)
+        return SE_ERR;
       ndp->xreturn[0] -= daya[0] * DEGTORAD;
       ndp->xreturn[3] -= daya[1] * DEGTORAD;
       swi_polcart_sp(ndp->xreturn, ndp->xreturn+6); 
@@ -5972,7 +5972,7 @@ static int32 fixstar_format_search_name(char *star, char *sstar, char *serr)
   if (cmplen == 0) {
     if (serr != NULL)
       sprintf(serr, "swe_fixstar(): star name empty");
-    return ERR; 
+    return SE_ERR; 
   }
   return OK;
 }
@@ -5986,7 +5986,7 @@ static int32 save_star_in_struct(int nrecs, struct fixed_star *fstp, char *serr)
   char *serr_alloc = "error in function load_all_fixed_stars(): could not resize fixed stars array";
   if ((swed.fixed_stars = realloc(swed.fixed_stars, nrecs * sizestru)) == NULL) {
     if (serr != NULL) strcpy(serr, serr_alloc);
-    return ERR;
+    return SE_ERR;
   }
   ftarget = swed.fixed_stars + (nrecs - 1);
   memcpy((void *) ftarget, (void *) fstp, sizestru);
@@ -6035,7 +6035,7 @@ int32 fixstar_cut_string(char *srecord, char *star, struct fixed_star *stardata,
 	sprintf(serr, "invalid line in fixed stars file: '%s'", s);
       }
     }
-    return ERR;
+    return SE_ERR;
   }
   if (strlen(cpos[0]) > SE_MAX_STNAME)
     cpos[0][SE_MAX_STNAME] = '\0';
@@ -6117,7 +6117,7 @@ int32 fixstar_cut_string(char *srecord, char *star, struct fixed_star *stardata,
  * this name as its search key.
  * The array is sorted in ascending order by search key. 
  *
- * If an error occurs, the function returns value ERR.
+ * If an error occurs, the function returns value SE_ERR.
  * If the stars were loaded at an earlier time the function returns
  * value -2, without doing anything and without error string.
  * On success, the function returns value OK.
@@ -6140,7 +6140,7 @@ static int32 load_all_fixed_stars(char *serr)
       if ((swed.fixfp = swi_fopen(SEI_FILE_FIXSTAR, SE_STARFILE_OLD, swed.ephepath, NULL)) == NULL) {
 	swed.is_old_starfile = FALSE;
 	/* no fixed star file available, error message is already in serr. */
-	return ERR;
+	return SE_ERR;
       }
     }
   }
@@ -6156,7 +6156,7 @@ static int32 load_all_fixed_stars(char *serr)
     line++;
     strcpy(srecord, s);
     retc = fixstar_cut_string(srecord, NULL, &fstdata, serr);
-    if (retc == ERR) return ERR;
+    if (retc == SE_ERR) return SE_ERR;
     // if star has a traditional name, save it with that name as its search key
     if (*fstdata.starname != '\0') {
       nrecs++;
@@ -6168,7 +6168,7 @@ static int32 load_all_fixed_stars(char *serr)
       // star name to lowercase and compare with search string
       for (sp = fstdata.skey; *sp != '\0'; sp++) 
 	*sp = tolower((int) *sp);
-      if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == ERR) return ERR;
+      if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == SE_ERR) return SE_ERR;
     }
     // also save it with Bayer designation as search key;
     // only if it has not been saved already
@@ -6182,11 +6182,11 @@ static int32 load_all_fixed_stars(char *serr)
     while ((sp = strchr(fstdata.skey, ' ')) != NULL)
       swi_strcpy(sp, sp+1);
     strcpy(last_starbayer, fstdata.starbayer);
-    if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == ERR) return ERR;
+    if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == SE_ERR) return SE_ERR;
     // also save it with sequential star number as search key (NO!!!!)
     // nrecs++;
     // sprintf(fstdata.skey, "%07d", nstars);
-    // if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == ERR) return ERR;
+    // if ((retc = save_star_in_struct(nrecs, &fstdata, serr)) == SE_ERR) return SE_ERR;
   }
   swed.n_fixstars_real = nstars;
   swed.n_fixstars_named = nnamed;
@@ -6315,10 +6315,10 @@ static int32 fixstar_calc_from_struct(struct fixed_star *stardata, double tjd, i
    ****************************************************/
   if (!(iflag & SEFLG_BARYCTR) && (!(iflag & SEFLG_HELCTR) || !(iflag & SEFLG_MOSEPH))) {
     if ((retc =  main_planet_bary(tjd - dt, SEI_EARTH, epheflag, iflag, NO_SAVE, xearth_dt, xearth_dt, xsun_dt, NULL, serr)) != OK) {
-      return ERR;
+      return SE_ERR;
     }
     if ((retc =  main_planet_bary(tjd, SEI_EARTH, epheflag, iflag, DO_SAVE, xearth, xearth, xsun, NULL, serr)) != OK) {
-      return ERR;
+      return SE_ERR;
     }
   }
   /************************************
@@ -6327,9 +6327,9 @@ static int32 fixstar_calc_from_struct(struct fixed_star *stardata, double tjd, i
   /* if topocentric position is wanted  */
   if (iflag & SEFLG_TOPOCTR) { 
     if (swi_get_observer(tjd - dt, iflag | SEFLG_NONUT, NO_SAVE, xobs_dt, serr) != OK)
-      return ERR;
+      return SE_ERR;
     if (swi_get_observer(tjd, iflag | SEFLG_NONUT, NO_SAVE, xobs, serr) != OK)
-      return ERR;
+      return SE_ERR;
     /* barycentric position of observer */
     for (i = 0; i <= 5; i++) {
       xobs[i] = xobs[i] + xearth[i];	
@@ -6431,7 +6431,7 @@ if (0) {
     /* rigorous algorithm */
     if (swed.sidd.sid_mode & SE_SIDBIT_ECL_T0) {
       if (swi_trop_ra2sid_lon(xxsv, x, xxsv, iflag) != OK)
-        return ERR;
+        return SE_ERR;
       if (iflag & SEFLG_EQUATORIAL) {
         for (i = 0; i <= 5; i++)
           x[i] = xxsv[i];
@@ -6439,7 +6439,7 @@ if (0) {
     /* project onto solar system equator */
     } else if (swed.sidd.sid_mode & SE_SIDBIT_SSY_PLANE) {
       if (swi_trop_ra2sid_lon_sosy(xxsv, x, iflag) != OK)
-	return ERR;
+	return SE_ERR;
       if (iflag & SEFLG_EQUATORIAL) {
         for (i = 0; i <= 5; i++)
           x[i] = xxsv[i];
@@ -6448,8 +6448,8 @@ if (0) {
     } else {
       swi_cartpol_sp(x, x); 
       // ACHTUNG: siehe Z. 2770!!!!!
-      if (swi_get_ayanamsa_with_speed(tjd, iflag, daya, serr) == ERR)
-        return ERR;
+      if (swi_get_ayanamsa_with_speed(tjd, iflag, daya, serr) == SE_ERR)
+        return SE_ERR;
       x[0] -= daya[0] * DEGTORAD;
       x[3] -= daya[1] * DEGTORAD;
       swi_polcart_sp(x, x); 
@@ -6507,7 +6507,7 @@ static int32 search_star_in_list(char *sstar, struct fixed_star *stardata, char
     if (star_nr > swed.n_fixstars_real) {
       if (serr != NULL) 
 	sprintf(serr, "error, swe_fixstar(): sequential fixed star number %d is not available", star_nr);
-      return ERR;
+      return SE_ERR;
     }
     *stardata = swed.fixed_stars[star_nr - 1]; // keys start from 1
     //printf("seq.number: %s, %s, %s, %f\n", stardata.skey, stardata.starname, stardata.starbayer, stardata.mag);
@@ -6519,7 +6519,7 @@ static int32 search_star_in_list(char *sstar, struct fixed_star *stardata, char
     if (sp - sstar != strlen(sstar) - 1) {
       if (serr != NULL)
 	sprintf(serr, "error, swe_fixstar(): invalid search string %s", sstar);
-      return ERR;
+      return SE_ERR;
     }
     strcpy(searchkey, sstar);
     len = strlen(sstar) - 1;
@@ -6532,7 +6532,7 @@ static int32 search_star_in_list(char *sstar, struct fixed_star *stardata, char
     }
     if (serr != NULL)
       sprintf(serr, "error, swe_fixstar(): star search string %s did not match", sstar);
-    return ERR;
+    return SE_ERR;
   /* traditional name or Bayer/Flamsteed: find it with binary search */
   } else {
     strcpy(searchkey, sstar);
@@ -6553,7 +6553,7 @@ static int32 search_star_in_list(char *sstar, struct fixed_star *stardata, char
     if (stardatap == NULL) {
       if (serr != NULL) 
 	sprintf(serr, "error, swe_fixstar(): could not find star name %s", sstar);
-      return ERR;
+      return SE_ERR;
     }
     *stardata = *stardatap;
     //printf("name search: %s, %s, %s, %f\n", stardata.skey, stardata.starname, stardata.starbayer, stardata.mag);
@@ -6655,7 +6655,7 @@ for (i = 0; i < swed.n_fixstars_records; i++) {
 exit(0);
 #endif
   retc = fixstar_format_search_name(star, sstar, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   /* star elements from last call: */
   if (swed.n_fixstars_records > 0 && strcmp(slast_starname, sstar) == 0) {
@@ -6673,14 +6673,14 @@ exit(0);
   /* sequential fixed star number: get it from array directly */
   } 
   retc = search_star_in_list(sstar, &stardata, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   /******************************************************/
   found:
   //strcpy(slast_stardata, srecord);
   last_stardata = stardata;
   strcpy(slast_starname, sstar);
-  if ((retc = fixstar_calc_from_struct(&stardata, tjd, iflag, star, xx, serr)) == ERR)
+  if ((retc = fixstar_calc_from_struct(&stardata, tjd, iflag, star, xx, serr)) == SE_ERR)
     goto return_err;
 #ifdef TRACE
   trace_swe_fixstar(2, star, tjd, iflag, xx, serr);
@@ -6710,7 +6710,7 @@ int32 CALL_CONV swe_fixstar2_ut(char *star, double tjd_ut, int32 iflag,
   deltat = swe_deltat_ex(tjd_ut, iflag, serr);
   /* if ephe required is not ephe returned, adjust delta t: */
   retflag = swe_fixstar2(star, tjd_ut + deltat, iflag, xx, serr);
-  if (retflag != ERR && (retflag & SEFLG_EPHMASK) != epheflag) {
+  if (retflag != SE_ERR && (retflag & SEFLG_EPHMASK) != epheflag) {
     deltat = swe_deltat_ex(tjd_ut, retflag, NULL);
     retflag = swe_fixstar2(star, tjd_ut + deltat, iflag, xx, NULL);
   }
@@ -6740,7 +6740,7 @@ int32 CALL_CONV swe_fixstar2_mag(char *star, double *mag, char *serr)
     *serr = '\0';
   load_all_fixed_stars(serr); // loads stars unless loaded with an earlier call of function
   retc = fixstar_format_search_name(star, sstar, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   /* star elements from last call: */
   if (swed.n_fixstars_records > 0 && strcmp(slast_starname, sstar) == 0) {
@@ -6749,7 +6749,7 @@ int32 CALL_CONV swe_fixstar2_mag(char *star, double *mag, char *serr)
     goto found;
   }
   retc = search_star_in_list(sstar, &stardata, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   /******************************************************/
   found:
@@ -6871,7 +6871,7 @@ char *CALL_CONV swe_get_planet_name(int ipl, char *s)
         /* else try to get it from ephemeris file */
 	else {
 	  retc = sweph(J2000, ipl, SEI_FILE_ANY_AST, 0, NULL, NO_SAVE, xp, NULL);
-	  if (retc != ERR && retc != NOT_AVAILABLE)
+	  if (retc != SE_ERR && retc != NOT_AVAILABLE)
 	    strcpy(s, swed.fidat[SEI_FILE_ANY_AST].astnam);
 	  else
 	    sprintf(s, "%d: not found", ipl - SE_AST_OFFSET);
@@ -7105,7 +7105,7 @@ int swi_get_observer(double tjd, int32 iflag,
   if (!swed.geopos_is_set) {
     if (serr != NULL)
       strcpy(serr, "geographic position has not been set");
-    return ERR;
+    return SE_ERR;
   }
   /* geocentric position of observer depends on sidereal time,
    * which depends on UT. 
@@ -7215,9 +7215,9 @@ int32 CALL_CONV swe_time_equ(double tjd_ut, double *E, char *serr)
   dt = t - floor(t);
   sidt -= dt * 24;
   sidt *= 15;
-  if ((retval = swe_calc_ut(tjd_ut, SE_SUN, iflag, x, serr)) == ERR) {
+  if ((retval = swe_calc_ut(tjd_ut, SE_SUN, iflag, x, serr)) == SE_ERR) {
     *E = 0;
-    return ERR;
+    return SE_ERR;
   }
   dt = swe_degnorm(sidt - x[0] - 180);
   if (dt > 180)
@@ -7302,8 +7302,8 @@ static int32 swi_fixstar_load_record(char *star, char *srecord, char *sname, cha
    * - traditional name to lower case (Bayer designation remains as it is)
    */
   retc = fixstar_format_search_name(star, sstar, serr);
-  if (retc == ERR)
-    return ERR;
+  if (retc == SE_ERR)
+    return SE_ERR;
   // search name is Bayer designation
   if (*sstar == ',') {
     is_bayer = TRUE;
@@ -7329,7 +7329,7 @@ static int32 swi_fixstar_load_record(char *star, char *srecord, char *sname, cha
       if ((swed.fixfp = swi_fopen(SEI_FILE_FIXSTAR, SE_STARFILE_OLD, swed.ephepath, NULL)) == NULL) {
 	swed.is_old_starfile = FALSE;
 	/* no fixed star file available, error message is already in serr. */
-	return ERR;
+	return SE_ERR;
       }
     }
   }
@@ -7349,7 +7349,7 @@ static int32 swi_fixstar_load_record(char *star, char *srecord, char *sname, cha
       if (serr != NULL) {
 	sprintf(serr, "star file %s damaged at line %d", SE_STARFILE, fline);
       }
-      return ERR;
+      return SE_ERR;
     } 
     // search string is Bayer or Flamsteed designation
     if (is_bayer) {
@@ -7383,12 +7383,12 @@ static int32 swi_fixstar_load_record(char *star, char *srecord, char *sname, cha
     if (strlen(serr) + strlen(star) < AS_MAXCH) {
       sprintf(serr, "star %s not found", star);
     }
-    return ERR;
+    return SE_ERR;
   }
   found:
   strcpy(srecord, s);
   retc = fixstar_cut_string(srecord, star, &stardata, serr);
-  if (retc == ERR) return ERR;
+  if (retc == SE_ERR) return SE_ERR;
   if (dparams != NULL) {
     dparams[0] = stardata.epoch; // epoch
     // RA(epoch)
@@ -7469,7 +7469,7 @@ static int32 swi_fixstar_calc_from_record(char *srecord, double tjd, int32 iflag
    ******************************************/
   swi_check_nutation(tjd, iflag);
   retc = fixstar_cut_string(srecord, star, &stardata, serr);
-  if (retc == ERR) return ERR;
+  if (retc == SE_ERR) return SE_ERR;
   epoch = stardata.epoch;
   ra_pm = stardata.ramot; de_pm = stardata.demot;
   radv = stardata.radvel; parall = stardata.parall; 
@@ -7529,11 +7529,11 @@ static int32 swi_fixstar_calc_from_record(char *srecord, double tjd, int32 iflag
    * for parallax, light deflection, and aberration,
    ****************************************************/
   if (!(iflag & SEFLG_BARYCTR) && (!(iflag & SEFLG_HELCTR) || !(iflag & SEFLG_MOSEPH))) {
-    if ((retc =  main_planet_bary(tjd - dt, SEI_EARTH, epheflag, iflag, NO_SAVE, xearth_dt, xearth_dt, xsun_dt, NULL, serr)) == ERR) {
-      return ERR;
+    if ((retc =  main_planet_bary(tjd - dt, SEI_EARTH, epheflag, iflag, NO_SAVE, xearth_dt, xearth_dt, xsun_dt, NULL, serr)) == SE_ERR) {
+      return SE_ERR;
     }
-    if ((retc =  main_planet_bary(tjd, SEI_EARTH, epheflag, iflag, DO_SAVE, xearth, xearth, xsun, NULL, serr)) == ERR) {
-      return ERR;
+    if ((retc =  main_planet_bary(tjd, SEI_EARTH, epheflag, iflag, DO_SAVE, xearth, xearth, xsun, NULL, serr)) == SE_ERR) {
+      return SE_ERR;
     }
   }
   /************************************
@@ -7542,9 +7542,9 @@ static int32 swi_fixstar_calc_from_record(char *srecord, double tjd, int32 iflag
   /* if topocentric position is wanted  */
   if (iflag & SEFLG_TOPOCTR) { 
     if (swi_get_observer(tjd - dt, iflag | SEFLG_NONUT, NO_SAVE, xobs_dt, serr) != OK)
-      return ERR;
+      return SE_ERR;
     if (swi_get_observer(tjd, iflag | SEFLG_NONUT, NO_SAVE, xobs, serr) != OK)
-      return ERR;
+      return SE_ERR;
     /* barycentric position of observer */
     for (i = 0; i <= 5; i++) {
       xobs[i] = xobs[i] + xearth[i];	
@@ -7645,7 +7645,7 @@ if (0) {
     /* rigorous algorithm */
     if (swed.sidd.sid_mode & SE_SIDBIT_ECL_T0) {
       if (swi_trop_ra2sid_lon(xxsv, x, xxsv, iflag) != OK)
-        return ERR;
+        return SE_ERR;
       if (iflag & SEFLG_EQUATORIAL) {
         for (i = 0; i <= 5; i++)
           x[i] = xxsv[i];
@@ -7653,7 +7653,7 @@ if (0) {
     /* project onto solar system equator */
     } else if (swed.sidd.sid_mode & SE_SIDBIT_SSY_PLANE) {
       if (swi_trop_ra2sid_lon_sosy(xxsv, x, iflag) != OK)
-	return ERR;
+	return SE_ERR;
       if (iflag & SEFLG_EQUATORIAL) {
         for (i = 0; i <= 5; i++)
           x[i] = xxsv[i];
@@ -7661,8 +7661,8 @@ if (0) {
     /* traditional algorithm */
     } else {
       swi_cartpol_sp(x, x); 
-      if (swi_get_ayanamsa_ex(tjd, iflag, &daya, serr) == ERR)
-        return ERR;
+      if (swi_get_ayanamsa_ex(tjd, iflag, &daya, serr) == SE_ERR)
+        return SE_ERR;
       x[0] -= daya * DEGTORAD;
       swi_polcart_sp(x, x); 
     }
@@ -7723,7 +7723,7 @@ int32 CALL_CONV swe_fixstar(char *star, double tjd, int32 iflag,
   trace_swe_fixstar(1, star, tjd, iflag, xx, serr);
 #endif /* TRACE */
   retc = fixstar_format_search_name(star, sstar, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   if (*sstar == ',') {
     ; // is Bayer designation
@@ -7753,7 +7753,7 @@ int32 CALL_CONV swe_fixstar(char *star, double tjd, int32 iflag,
   found:
   strcpy(slast_stardata, srecord);
   strcpy(slast_starname, sstar);
-  if ((retc = swi_fixstar_calc_from_record(srecord, tjd, iflag, star, xx, serr)) == ERR)
+  if ((retc = swi_fixstar_calc_from_record(srecord, tjd, iflag, star, xx, serr)) == SE_ERR)
     goto return_err;
 #ifdef TRACE
   trace_swe_fixstar(2, star, tjd, iflag, xx, serr);
@@ -7783,7 +7783,7 @@ int32 CALL_CONV swe_fixstar_ut(char *star, double tjd_ut, int32 iflag,
   deltat = swe_deltat_ex(tjd_ut, iflag, serr);
   /* if ephe required is not ephe returned, adjust delta t: */
   retflag = swe_fixstar(star, tjd_ut + deltat, iflag, xx, serr);
-  if (retflag != ERR && (retflag & SEFLG_EPHMASK) != epheflag) {
+  if (retflag != SE_ERR && (retflag & SEFLG_EPHMASK) != epheflag) {
     deltat = swe_deltat_ex(tjd_ut, retflag, NULL);
     retflag = swe_fixstar(star, tjd_ut + deltat, iflag, xx, NULL);
   }
@@ -7812,7 +7812,7 @@ int32 CALL_CONV swe_fixstar_mag(char *star, double *mag, char *serr)
   if (serr != NULL)
     *serr = '\0';
   retc = fixstar_format_search_name(star, sstar, serr);
-  if (retc == ERR)
+  if (retc == SE_ERR)
     goto return_err;
   if (*sstar == ',') {
     ; // is Bayer designation
@@ -7873,8 +7873,8 @@ int CALL_CONV swe_time_equ(double tjd_ut, double *E, char *serr)
   swi_nutation(tjd, 0, nutlo);
   eps = (swi_epsiln(tjd) + nutlo[1]) * RADTODEG;
   dpsi = nutlo[0] * RADTODEG;
-  if (swe_calc(tjd, SE_SUN, SEFLG_EQUATORIAL, x, serr) == ERR)
-    return ERR;
+  if (swe_calc(tjd, SE_SUN, SEFLG_EQUATORIAL, x, serr) == SE_ERR)
+    return SE_ERR;
   *E = swe_degnorm(L0 - 0.0057183 - x[0] + dpsi * cos(eps * DEGTORAD));
   if (*E > 180)
     *E -= 360;
diff --git a/src/libswe/sweph.h b/src/libswe/sweph.h
index c1f40e5..d084602 100644
--- a/src/libswe/sweph.h
+++ b/src/libswe/sweph.h
@@ -248,7 +248,7 @@
 #define NCTIES         6.0     /* number of centuries per eph. file */
 
 #define OK (0)
-#define ERR (-1)
+#define SE_ERR (-1)
 #define NOT_AVAILABLE (-2)
 #define BEYOND_EPH_LIMITS (-3)
 
diff --git a/src/libswe/swephlib.c b/src/libswe/swephlib.c
index facd8a5..583cebb 100644
--- a/src/libswe/swephlib.c
+++ b/src/libswe/swephlib.c
@@ -1989,15 +1989,15 @@ int swi_nutation(double tjd, int32 iflag, double *nutlo)
       swed.interpol.tjd_nut0 = tjd - 1.0; // one day earlier
       swed.interpol.tjd_nut2 = tjd + 1.0; // one day later
       retc = calc_nutation(swed.interpol.tjd_nut0, iflag, dnut);
-      if (retc == ERR) return ERR;
+      if (retc == SE_ERR) return SE_ERR;
       swed.interpol.nut_dpsi0 = dnut[0];
       swed.interpol.nut_deps0 = dnut[1];
       retc = calc_nutation(swed.interpol.tjd_nut2, iflag, dnut);
-      if (retc == ERR) return ERR;
+      if (retc == SE_ERR) return SE_ERR;
       swed.interpol.nut_dpsi2 = dnut[0];
       swed.interpol.nut_deps2 = dnut[1];
       retc = calc_nutation(tjd, iflag, nutlo);
-      if (retc == ERR) return ERR;
+      if (retc == SE_ERR) return SE_ERR;
       swed.interpol.nut_dpsi1 = nutlo[0];
       swed.interpol.nut_deps1 = nutlo[1];
     }
